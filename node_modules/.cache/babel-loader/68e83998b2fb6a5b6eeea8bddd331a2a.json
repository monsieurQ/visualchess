{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _Reflect$construct = require(\"@babel/runtime-corejs2/core-js/reflect/construct\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = exports.AlgebraicGameClient = void 0;\n\nvar _parseInt2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/parse-int\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/getPrototypeOf\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _piece = require(\"./piece\");\n\nvar _events = require(\"events\");\n\nvar _game = require(\"./game\");\n\nvar _gameValidation = require(\"./gameValidation\");\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = _Reflect$construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false;\n  if (_Reflect$construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(_Reflect$construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n} // private methods\n\n\nfunction getNotationPrefix(src, dest, movesForPiece) {\n  var containsDest = function containsDest(squares) {\n    var n = 0;\n\n    for (; n < squares.length; n++) {\n      if (squares[n] === dest) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n      file = '',\n      fileHash = {},\n      i = 0,\n      prefix = src.piece.notation,\n      rank = 0,\n      rankHash = {};\n\n  for (; i < movesForPiece.length; i++) {\n    if (containsDest(movesForPiece[i].squares)) {\n      file = movesForPiece[i].src.file;\n      rank = movesForPiece[i].src.rank;\n      fileHash[file] = typeof fileHash[file] !== 'undefined' ? fileHash[file] + 1 : 1;\n      rankHash[rank] = typeof rankHash[rank] !== 'undefined' ? rankHash[rank] + 1 : 1;\n    }\n  }\n\n  if ((0, _keys[\"default\"])(fileHash).length > 1) {\n    prefix += src.file;\n  }\n\n  if ((0, _keys[\"default\"])(rankHash).length > (0, _keys[\"default\"])(fileHash).length) {\n    prefix += src.rank;\n  }\n\n  return prefix;\n}\n\nfunction getValidMovesByPieceType(pieceType, validMoves) {\n  var byPiece = [],\n      i = 0;\n\n  for (; i < validMoves.length; i++) {\n    if (validMoves[i].src.piece.type === pieceType) {\n      byPiece.push(validMoves[i]);\n    }\n  }\n\n  return byPiece;\n}\n\nfunction notate(validMoves, gameClient) {\n  var algebraicNotation = {},\n      i = 0,\n      isPromotion = false,\n      movesForPiece = [],\n      n = 0,\n      p = null,\n      prefix = '',\n      sq = null,\n      src = null,\n      suffix = ''; // iterate through each starting squares valid moves\n\n  for (; i < validMoves.length; i++) {\n    src = validMoves[i].src;\n    p = src.piece; // iterate each potential move and build prefix and suffix for notation\n\n    for (n = 0; n < validMoves[i].squares.length; n++) {\n      prefix = '';\n      sq = validMoves[i].squares[n]; // set suffix for notation\n\n      suffix = (sq.piece ? 'x' : '') + sq.file + sq.rank; // check for potential promotion\n\n      /* eslint no-magic-numbers: 0 */\n\n      isPromotion = (sq.rank === 8 || sq.rank === 1) && p.type === _piece.PieceType.Pawn; // squares with pawns\n\n      if (sq.piece && p.type === _piece.PieceType.Pawn) {\n        prefix = src.file;\n      } // en passant\n      // fix for #53\n\n\n      if (p.type === _piece.PieceType.Pawn && src.file !== sq.file && !sq.piece) {\n        prefix = [src.file, 'x'].join('');\n      } // squares with Bishop, Knight, Queen or Rook pieces\n\n\n      if (p.type === _piece.PieceType.Bishop || p.type === _piece.PieceType.Knight || p.type === _piece.PieceType.Queen || p.type === _piece.PieceType.Rook) {\n        // if there is more than 1 of the specified piece on the board,\n        // can more than 1 land on the specified square?\n        movesForPiece = getValidMovesByPieceType(p.type, validMoves);\n\n        if (movesForPiece.length > 1) {\n          prefix = getNotationPrefix(src, sq, movesForPiece);\n        } else {\n          prefix = src.piece.notation;\n        }\n      } // squares with a King piece\n\n\n      if (p.type === _piece.PieceType.King) {\n        // look for castle left and castle right\n        if (src.file === 'e' && sq.file === 'g') {\n          // fix for issue #13 - if PGN is specified should be letters, not numbers\n          prefix = gameClient.PGN ? 'O-O' : '0-0';\n          suffix = '';\n        } else if (src.file === 'e' && sq.file === 'c') {\n          // fix for issue #13 - if PGN is specified should be letters, not numbers\n          prefix = gameClient.PGN ? 'O-O-O' : '0-0-0';\n          suffix = '';\n        } else {\n          prefix = src.piece.notation;\n        }\n      } // set the notation\n\n\n      if (isPromotion) {\n        // Rook promotion\n        algebraicNotation[prefix + suffix + 'R'] = {\n          dest: sq,\n          src: src\n        }; // Knight promotion\n\n        algebraicNotation[prefix + suffix + 'N'] = {\n          dest: sq,\n          src: src\n        }; // Bishop promotion\n\n        algebraicNotation[prefix + suffix + 'B'] = {\n          dest: sq,\n          src: src\n        }; // Queen promotion\n\n        algebraicNotation[prefix + suffix + 'Q'] = {\n          dest: sq,\n          src: src\n        };\n      } else {\n        algebraicNotation[prefix + suffix] = {\n          dest: sq,\n          src: src\n        };\n      }\n    }\n  }\n\n  return algebraicNotation;\n}\n\nfunction parseNotation(notation) {\n  var captureRegex = /^[a-h]x[a-h][1-8]$/,\n      parseDest = ''; // try and parse the notation\n\n  parseDest = notation.substring(notation.length - 2);\n\n  if (notation.length > 2) {\n    // check for preceding pawn capture style notation (i.e. a-h x)\n    if (captureRegex.test(notation)) {\n      return parseDest;\n    }\n\n    return notation.charAt(0) + parseDest;\n  }\n\n  return '';\n}\n\nfunction updateGameClient(gameClient) {\n  gameClient.validation.start(function (err, result) {\n    if (err) {\n      throw new Error(err);\n    }\n\n    gameClient.isCheck = result.isCheck;\n    gameClient.isCheckmate = result.isCheckmate;\n    gameClient.isRepetition = result.isRepetition;\n    gameClient.isStalemate = result.isStalemate;\n    gameClient.notatedMoves = notate(result.validMoves, gameClient);\n    gameClient.validMoves = result.validMoves;\n  });\n}\n\nvar AlgebraicGameClient = /*#__PURE__*/function (_EventEmitter) {\n  (0, _inherits2[\"default\"])(AlgebraicGameClient, _EventEmitter);\n\n  var _super = _createSuper(AlgebraicGameClient);\n\n  function AlgebraicGameClient(game, opts) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, AlgebraicGameClient);\n    _this = _super.call(this);\n    _this.game = game;\n    _this.isCheck = false;\n    _this.isCheckmate = false;\n    _this.isRepetition = false;\n    _this.isStalemate = false;\n    _this.notatedMoves = {}; // for issue #13, adding options allowing consumers to specify\n    // PGN (Portable Game Notation)... essentially, this makes castle moves\n    // appear as capital letter O rather than the number 0\n\n    _this.PGN = opts && typeof opts.PGN === 'boolean' ? opts.PGN : false;\n    _this.validMoves = [];\n    _this.validation = _gameValidation.GameValidation.create(_this.game); // bubble the game and board events\n\n    ['check', 'checkmate'].forEach(function (ev) {\n      _this.game.on(ev, function (data) {\n        return _this.emit(ev, data);\n      });\n    });\n    ['capture', 'castle', 'enPassant', 'move', 'promote'].forEach(function (ev) {\n      _this.game.board.on(ev, function (data) {\n        return _this.emit(ev, data);\n      });\n    });\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(AlgebraicGameClient, [{\n    key: \"getStatus\",\n    value: function getStatus(forceUpdate) {\n      if (forceUpdate) {\n        updateGameClient(this);\n      }\n\n      return {\n        board: this.game.board,\n        isCheck: this.isCheck,\n        isCheckmate: this.isCheckmate,\n        isRepetition: this.isRepetition,\n        isStalemate: this.isStalemate,\n        notatedMoves: this.notatedMoves\n      };\n    }\n  }, {\n    key: \"getFen\",\n    value: function getFen() {\n      var fen = [];\n      var squares = this.game.board.squares.reduce(function (acc, cur, idx) {\n        var outerIdx = (0, _parseInt2[\"default\"])(idx / 8, 10);\n        acc[outerIdx] = acc[outerIdx] || [];\n        acc[outerIdx].push(cur);\n        return acc;\n      }, []).flatMap(function (row) {\n        return row.reverse();\n      }).reverse();\n\n      for (var i = 0; i < squares.length; i += 1) {\n        var square = squares[i];\n\n        if (square.file === 'a' && square.rank < 8) {\n          fen.push('/');\n        }\n\n        if (square.piece) {\n          var transform = \"to\".concat(square.piece.side.name === 'white' ? 'Upp' : 'Low', \"erCase\");\n          fen.push((square.piece.notation || 'p')[transform]());\n        } else {\n          if (isNaN(Number(fen[fen.length - 1]))) {\n            fen.push(1);\n          } else {\n            fen[fen.length - 1] += 1;\n          }\n        }\n      }\n\n      return fen.join('');\n    }\n  }, {\n    key: \"move\",\n    value: function move(notation, isFuzzy) {\n      var move = null,\n          notationRegex = /^[BKQNR]?[a-h]?[1-8]?[x-]?[a-h][1-8][+#]?$/,\n          p = null,\n          promo = '',\n          side = this.game.getCurrentSide();\n\n      if (notation && typeof notation === 'string') {\n        // clean notation of extra or alternate chars\n        notation = notation.replace(/\\!/g, '').replace(/\\+/g, '').replace(/\\#/g, '').replace(/\\=/g, '').replace(/\\\\/g, ''); // fix for issue #13 - if PGN is specified, should be letters not numbers\n\n        if (this.PGN) {\n          notation = notation.replace(/0/g, 'O');\n        } else {\n          notation = notation.replace(/O/g, '0');\n        } // check for pawn promotion\n\n\n        if (notation.charAt(notation.length - 1).match(/[BNQR]/)) {\n          promo = notation.charAt(notation.length - 1);\n        } // use it directly or attempt to parse it if not found\n\n\n        if (this.notatedMoves[notation]) {\n          move = this.game.board.move(this.notatedMoves[notation].src, this.notatedMoves[notation].dest, notation);\n        } else if (notation.match(notationRegex) && notation.length > 1 && !isFuzzy) {\n          return this.move(parseNotation(notation), true);\n        } else if (isFuzzy) {\n          throw new Error(\"Invalid move (\".concat(notation, \")\"));\n        }\n\n        if (move) {\n          // apply pawn promotion\n          if (promo) {\n            switch (promo) {\n              case 'B':\n                p = _piece.Piece.createBishop(side);\n                break;\n\n              case 'N':\n                p = _piece.Piece.createKnight(side);\n                break;\n\n              case 'Q':\n                p = _piece.Piece.createQueen(side);\n                break;\n\n              case 'R':\n                p = _piece.Piece.createRook(side);\n                break;\n\n              default:\n                p = _piece.Piece.createPawn(side);\n            }\n\n            if (p) {\n              this.game.board.promote(move.move.postSquare, p);\n              /*\n              p.moveCount = move.move.postSquare.piece.moveCount;\n              move.move.postSquare.piece = p;\n              //*/\n            }\n          }\n\n          updateGameClient(this);\n          return move;\n        }\n      }\n\n      throw new Error(\"Notation is invalid (\".concat(notation, \")\"));\n    }\n  }], [{\n    key: \"create\",\n    value: function create(opts) {\n      var game = _game.Game.create(),\n          gameClient = new AlgebraicGameClient(game, opts);\n\n      updateGameClient(gameClient);\n      return gameClient;\n    }\n  }]);\n  return AlgebraicGameClient;\n}(_events.EventEmitter);\n\nexports.AlgebraicGameClient = AlgebraicGameClient;\nvar _default = {\n  AlgebraicGameClient: AlgebraicGameClient\n};\nexports[\"default\"] = _default;","map":{"version":3,"sources":["algebraicGameClient.js"],"names":["containsDest","n","squares","file","fileHash","i","prefix","src","rank","rankHash","movesForPiece","byPiece","validMoves","algebraicNotation","isPromotion","p","sq","suffix","PieceType","getValidMovesByPieceType","getNotationPrefix","gameClient","dest","captureRegex","parseDest","notation","result","notate","AlgebraicGameClient","EventEmitter","opts","GameValidation","game","Game","updateGameClient","forceUpdate","board","isCheck","isCheckmate","isRepetition","isStalemate","notatedMoves","fen","outerIdx","idx","acc","row","square","transform","isNaN","Number","isFuzzy","move","notationRegex","promo","side","parseNotation","Piece"],"mappings":"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","sourcesContent":["import { Piece, PieceType } from './piece';\nimport { EventEmitter } from 'events';\nimport { Game } from './game';\nimport { GameValidation } from './gameValidation';\n\n// private methods\nfunction getNotationPrefix (src, dest, movesForPiece) {\n\tlet\n\t\tcontainsDest = (squares) => {\n\t\t\tlet n = 0;\n\n\t\t\tfor (; n < squares.length; n++) {\n\t\t\t\tif (squares[n] === dest) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\t\tfile = '',\n\t\tfileHash = {},\n\t\ti = 0,\n\t\tprefix = src.piece.notation,\n\t\trank = 0,\n\t\trankHash = {};\n\n\tfor (; i < movesForPiece.length; i++) {\n\t\tif (containsDest(movesForPiece[i].squares)) {\n\t\t\tfile = movesForPiece[i].src.file;\n\t\t\trank = movesForPiece[i].src.rank;\n\n\t\t\tfileHash[file] = (typeof fileHash[file] !== 'undefined' ? fileHash[file] + 1 : 1);\n\t\t\trankHash[rank] = (typeof rankHash[rank] !== 'undefined' ? rankHash[rank] + 1 : 1);\n\t\t}\n\t}\n\n\tif (Object.keys(fileHash).length > 1) {\n\t\tprefix += src.file;\n\t}\n\n\tif (Object.keys(rankHash).length > Object.keys(fileHash).length) {\n\t\tprefix += src.rank;\n\t}\n\n\treturn prefix;\n}\n\nfunction getValidMovesByPieceType (pieceType, validMoves) {\n\tlet\n\t\tbyPiece = [],\n\t\ti = 0;\n\n\tfor (; i < validMoves.length; i++) {\n\t\tif (validMoves[i].src.piece.type === pieceType) {\n\t\t\tbyPiece.push(validMoves[i]);\n\t\t}\n\t}\n\n\treturn byPiece;\n}\n\nfunction notate (validMoves, gameClient) {\n\tlet\n\t\talgebraicNotation = {},\n\t\ti = 0,\n\t\tisPromotion = false,\n\t\tmovesForPiece = [],\n\t\tn = 0,\n\t\tp = null,\n\t\tprefix = '',\n\t\tsq = null,\n\t\tsrc = null,\n\t\tsuffix = '';\n\n\t// iterate through each starting squares valid moves\n\tfor (; i < validMoves.length; i++) {\n\t\tsrc = validMoves[i].src;\n\t\tp = src.piece;\n\n\t\t// iterate each potential move and build prefix and suffix for notation\n\t\tfor (n = 0; n < validMoves[i].squares.length; n++) {\n\t\t\tprefix = '';\n\t\t\tsq = validMoves[i].squares[n];\n\n\t\t\t// set suffix for notation\n\t\t\tsuffix = (sq.piece ? 'x' : '') + sq.file + sq.rank;\n\n\t\t\t// check for potential promotion\n\t\t\t/* eslint no-magic-numbers: 0 */\n\t\t\tisPromotion =\n\t\t\t\t(sq.rank === 8 || sq.rank === 1) &&\n\t\t\t\tp.type === PieceType.Pawn;\n\n\t\t\t// squares with pawns\n\t\t\tif (sq.piece && p.type === PieceType.Pawn) {\n\t\t\t\tprefix = src.file;\n\t\t\t}\n\n\t\t\t// en passant\n\t\t\t// fix for #53\n\t\t\tif (p.type === PieceType.Pawn &&\n\t\t\t\tsrc.file !== sq.file &&\n\t\t\t\t!sq.piece) {\n\t\t\t\tprefix = [src.file, 'x'].join('');\n\t\t\t}\n\n\t\t\t// squares with Bishop, Knight, Queen or Rook pieces\n\t\t\tif (p.type === PieceType.Bishop ||\n\t\t\t\tp.type === PieceType.Knight ||\n\t\t\t\tp.type === PieceType.Queen ||\n\t\t\t\tp.type === PieceType.Rook) {\n\t\t\t\t// if there is more than 1 of the specified piece on the board,\n\t\t\t\t// can more than 1 land on the specified square?\n\t\t\t\tmovesForPiece = getValidMovesByPieceType(p.type, validMoves);\n\t\t\t\tif (movesForPiece.length > 1) {\n\t\t\t\t\tprefix = getNotationPrefix(src, sq, movesForPiece);\n\t\t\t\t} else {\n\t\t\t\t\tprefix = src.piece.notation;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// squares with a King piece\n\t\t\tif (p.type === PieceType.King) {\n\t\t\t\t// look for castle left and castle right\n\t\t\t\tif (src.file === 'e' && sq.file === 'g') {\n\t\t\t\t\t// fix for issue #13 - if PGN is specified should be letters, not numbers\n\t\t\t\t\tprefix = gameClient.PGN ? 'O-O' : '0-0';\n\t\t\t\t\tsuffix = '';\n\t\t\t\t} else if (src.file === 'e' && sq.file === 'c') {\n\t\t\t\t\t// fix for issue #13 - if PGN is specified should be letters, not numbers\n\t\t\t\t\tprefix = gameClient.PGN ? 'O-O-O' : '0-0-0';\n\t\t\t\t\tsuffix = '';\n\t\t\t\t} else {\n\t\t\t\t\tprefix = src.piece.notation;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set the notation\n\t\t\tif (isPromotion) {\n\t\t\t\t// Rook promotion\n\t\t\t\talgebraicNotation[prefix + suffix + 'R'] = {\n\t\t\t\t\tdest : sq,\n\t\t\t\t\tsrc\n\t\t\t\t};\n\n\t\t\t\t// Knight promotion\n\t\t\t\talgebraicNotation[prefix + suffix + 'N'] = {\n\t\t\t\t\tdest : sq,\n\t\t\t\t\tsrc\n\t\t\t\t};\n\n\t\t\t\t// Bishop promotion\n\t\t\t\talgebraicNotation[prefix + suffix + 'B'] = {\n\t\t\t\t\tdest : sq,\n\t\t\t\t\tsrc\n\t\t\t\t};\n\n\t\t\t\t// Queen promotion\n\t\t\t\talgebraicNotation[prefix + suffix + 'Q'] = {\n\t\t\t\t\tdest : sq,\n\t\t\t\t\tsrc\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\talgebraicNotation[prefix + suffix] = {\n\t\t\t\t\tdest : sq,\n\t\t\t\t\tsrc\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn algebraicNotation;\n}\n\nfunction parseNotation (notation) {\n\tlet\n\t\tcaptureRegex = /^[a-h]x[a-h][1-8]$/,\n\t\tparseDest = '';\n\n\t// try and parse the notation\n\tparseDest = notation.substring(notation.length - 2);\n\n\tif (notation.length > 2) {\n\t\t// check for preceding pawn capture style notation (i.e. a-h x)\n\t\tif (captureRegex.test(notation)) {\n\t\t\treturn parseDest;\n\t\t}\n\n\t\treturn notation.charAt(0) + parseDest;\n\t}\n\n\treturn '';\n}\n\nfunction updateGameClient (gameClient) {\n\tgameClient.validation.start((err, result) => {\n\t\tif (err) {\n\t\t\tthrow new Error(err);\n\t\t}\n\n\t\tgameClient.isCheck = result.isCheck;\n\t\tgameClient.isCheckmate = result.isCheckmate;\n\t\tgameClient.isRepetition = result.isRepetition;\n\t\tgameClient.isStalemate = result.isStalemate;\n\t\tgameClient.notatedMoves = notate(result.validMoves, gameClient);\n\t\tgameClient.validMoves = result.validMoves;\n\t});\n}\n\nexport class AlgebraicGameClient extends EventEmitter {\n\tconstructor (game, opts) {\n\t\tsuper();\n\n\t\tthis.game = game;\n\t\tthis.isCheck = false;\n\t\tthis.isCheckmate = false;\n\t\tthis.isRepetition = false;\n\t\tthis.isStalemate = false;\n\t\tthis.notatedMoves = {};\n\t\t// for issue #13, adding options allowing consumers to specify\n\t\t// PGN (Portable Game Notation)... essentially, this makes castle moves\n\t\t// appear as capital letter O rather than the number 0\n\t\tthis.PGN = (opts && typeof opts.PGN === 'boolean') ? opts.PGN : false;\n\t\tthis.validMoves = [];\n\t\tthis.validation = GameValidation.create(this.game);\n\n\t\t// bubble the game and board events\n\t\t['check', 'checkmate'].forEach((ev) => {\n\t\t\tthis.game.on(ev, (data) => this.emit(ev, data));\n\t\t});\n\n\t\t['capture', 'castle', 'enPassant', 'move', 'promote'].forEach((ev) => {\n\t\t\tthis.game.board.on(ev, (data) => this.emit(ev, data));\n\t\t});\n\t}\n\n\tstatic create (opts) {\n\t\tlet\n\t\t\tgame = Game.create(),\n\t\t\tgameClient = new AlgebraicGameClient(game, opts);\n\n\t\tupdateGameClient(gameClient);\n\n\t\treturn gameClient;\n\t}\n\n\tgetStatus (forceUpdate) {\n\t\tif (forceUpdate) {\n\t\t\tupdateGameClient(this);\n\t\t}\n\n\t\treturn {\n\t\t\tboard : this.game.board,\n\t\t\tisCheck : this.isCheck,\n\t\t\tisCheckmate : this.isCheckmate,\n\t\t\tisRepetition : this.isRepetition,\n\t\t\tisStalemate : this.isStalemate,\n\t\t\tnotatedMoves : this.notatedMoves\n\t\t};\n\t}\n\n\tgetFen () {\n\t\tconst fen = [];\n\t\tconst squares = this.game.board.squares\n\t\t\t.reduce((acc, cur, idx) => {\n\t\t\t\tconst outerIdx = parseInt(idx / 8, 10);\n\t\t\t\tacc[outerIdx] = acc[outerIdx] || [];\n\t\t\t\tacc[outerIdx].push(cur);\n\t\t\t\treturn acc;\n\t\t\t}, [])\n\t\t\t.flatMap((row) => row.reverse())\n\t\t\t.reverse();\n\n\t\tfor (let i = 0; i < squares.length; i += 1) {\n\t\t\tconst square = squares[i];\n\n\t\t\tif (square.file === 'a' && square.rank < 8) {\n\t\t\t\tfen.push('/');\n\t\t\t}\n\n\t\t\tif (square.piece) {\n\t\t\t\tconst transform = `to${square.piece.side.name === 'white' ? 'Upp' : 'Low'}erCase`;\n\t\t\t\tfen.push((square.piece.notation || 'p')[transform]());\n\t\t\t} else {\n\t\t\t\tif (isNaN(Number(fen[fen.length - 1]))) {\n\t\t\t\t\tfen.push(1);\n\t\t\t\t} else {\n\t\t\t\t\tfen[fen.length - 1] += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fen.join('');\n\t}\n\n\tmove (notation, isFuzzy) {\n\t\tlet\n\t\t\tmove = null,\n\t\t\tnotationRegex = /^[BKQNR]?[a-h]?[1-8]?[x-]?[a-h][1-8][+#]?$/,\n\t\t\tp = null,\n\t\t\tpromo = '',\n\t\t\tside = this.game.getCurrentSide();\n\n\t\tif (notation && typeof notation === 'string') {\n\t\t\t// clean notation of extra or alternate chars\n\t\t\tnotation = notation\n\t\t\t\t.replace(/\\!/g, '')\n\t\t\t\t.replace(/\\+/g, '')\n\t\t\t\t.replace(/\\#/g, '')\n\t\t\t\t.replace(/\\=/g, '')\n\t\t\t\t.replace(/\\\\/g, '');\n\n\t\t\t// fix for issue #13 - if PGN is specified, should be letters not numbers\n\t\t\tif (this.PGN) {\n\t\t\t\tnotation = notation.replace(/0/g, 'O');\n\t\t\t} else {\n\t\t\t\tnotation = notation.replace(/O/g, '0');\n\t\t\t}\n\n\t\t\t// check for pawn promotion\n\t\t\tif (notation.charAt(notation.length - 1).match(/[BNQR]/)) {\n\t\t\t\tpromo = notation.charAt(notation.length - 1);\n\t\t\t}\n\n\t\t\t// use it directly or attempt to parse it if not found\n\t\t\tif (this.notatedMoves[notation]) {\n\t\t\t\tmove = this.game.board.move(\n\t\t\t\t\tthis.notatedMoves[notation].src,\n\t\t\t\t\tthis.notatedMoves[notation].dest,\n\t\t\t\t\tnotation);\n\t\t\t} else if (notation.match(notationRegex) && notation.length > 1 && !isFuzzy) {\n\t\t\t\treturn this.move(parseNotation(notation), true);\n\t\t\t} else if (isFuzzy) {\n\t\t\t\tthrow new Error(`Invalid move (${notation})`);\n\t\t\t}\n\n\t\t\tif (move) {\n\t\t\t\t// apply pawn promotion\n\t\t\t\tif (promo) {\n\t\t\t\t\tswitch (promo) {\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\tp = Piece.createBishop(side);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'N':\n\t\t\t\t\t\t\tp = Piece.createKnight(side);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\t\tp = Piece.createQueen(side);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\tp = Piece.createRook(side);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tp = Piece.createPawn(side);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tthis.game.board.promote(move.move.postSquare, p);\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tp.moveCount = move.move.postSquare.piece.moveCount;\n\t\t\t\t\t\tmove.move.postSquare.piece = p;\n\t\t\t\t\t\t//*/\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tupdateGameClient(this);\n\n\t\t\t\treturn move;\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(`Notation is invalid (${notation})`);\n\t}\n}\n\nexport default { AlgebraicGameClient };\n"]},"metadata":{},"sourceType":"script"}