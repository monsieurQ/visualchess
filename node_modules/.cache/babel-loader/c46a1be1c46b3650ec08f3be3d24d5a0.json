{"ast":null,"code":"/*\n * Copyright (c) 2017, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\n\n/* minified license below  */\n\n/* @license\n * Copyright (c) 2017, Jeff Hlywa (jhlywa@gmail.com)\n * Released under the BSD license\n * https://github.com/jhlywa/chess.js/blob/master/LICENSE\n */\nvar Chess = function (fen) {\n  // funciton returns a closure object\n\n  /* jshint indent: false */\n  var BLACK = 'b';\n  var WHITE = 'w';\n  var EMPTY = -1;\n  var PAWN = 'p';\n  var KNIGHT = 'n';\n  var BISHOP = 'b';\n  var ROOK = 'r';\n  var QUEEN = 'q';\n  var KING = 'k';\n  var SYMBOLS = 'pnbrqkPNBRQK';\n  var DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\n  var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*'];\n  var PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15]\n  };\n  var PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1]\n  };\n  var ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20];\n  var RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\n  var SHIFTS = {\n    p: 0,\n    n: 1,\n    b: 2,\n    r: 3,\n    q: 4,\n    k: 5\n  };\n  var FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q'\n  };\n  var BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64\n  };\n  var RANK_1 = 7;\n  var RANK_2 = 6;\n  var RANK_3 = 5;\n  var RANK_4 = 4;\n  var RANK_5 = 3;\n  var RANK_6 = 2;\n  var RANK_7 = 1;\n  var RANK_8 = 0;\n  var SQUARES = {\n    a8: 0,\n    b8: 1,\n    c8: 2,\n    d8: 3,\n    e8: 4,\n    f8: 5,\n    g8: 6,\n    h8: 7,\n    a7: 16,\n    b7: 17,\n    c7: 18,\n    d7: 19,\n    e7: 20,\n    f7: 21,\n    g7: 22,\n    h7: 23,\n    a6: 32,\n    b6: 33,\n    c6: 34,\n    d6: 35,\n    e6: 36,\n    f6: 37,\n    g6: 38,\n    h6: 39,\n    a5: 48,\n    b5: 49,\n    c5: 50,\n    d5: 51,\n    e5: 52,\n    f5: 53,\n    g5: 54,\n    h5: 55,\n    a4: 64,\n    b4: 65,\n    c4: 66,\n    d4: 67,\n    e4: 68,\n    f4: 69,\n    g4: 70,\n    h4: 71,\n    a3: 80,\n    b3: 81,\n    c3: 82,\n    d3: 83,\n    e3: 84,\n    f3: 85,\n    g3: 86,\n    h3: 87,\n    a2: 96,\n    b2: 97,\n    c2: 98,\n    d2: 99,\n    e2: 100,\n    f2: 101,\n    g2: 102,\n    h2: 103,\n    a1: 112,\n    b1: 113,\n    c1: 114,\n    d1: 115,\n    e1: 116,\n    f1: 117,\n    g1: 118,\n    h1: 119\n  };\n  var ROOKS = {\n    w: [{\n      square: SQUARES.a1,\n      flag: BITS.QSIDE_CASTLE\n    }, {\n      square: SQUARES.h1,\n      flag: BITS.KSIDE_CASTLE\n    }],\n    b: [{\n      square: SQUARES.a8,\n      flag: BITS.QSIDE_CASTLE\n    }, {\n      square: SQUARES.h8,\n      flag: BITS.KSIDE_CASTLE\n    }]\n  };\n  var board = new Array(128);\n  var kings = {\n    w: EMPTY,\n    b: EMPTY\n  };\n  var turn = WHITE;\n  var castling = {\n    w: 0,\n    b: 0\n  };\n  var ep_square = EMPTY;\n  var half_moves = 0;\n  var move_number = 1;\n  var history = [];\n  var header = {};\n  var fen_history = [];\n  var fh_curr = 0;\n  /* if the user passes in a fen string, load it, else default to\n   * starting position\n   */\n\n  if (typeof fen === 'undefined') {\n    load(DEFAULT_POSITION);\n  } else {\n    load(fen);\n  }\n\n  function clear(keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n\n    board = new Array(128);\n    kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    turn = WHITE;\n    castling = {\n      w: 0,\n      b: 0\n    };\n    ep_square = EMPTY;\n    half_moves = 0;\n    move_number = 1;\n    history = [];\n    if (!keep_headers) header = {};\n    update_setup(generate_fen());\n  }\n\n  function reset() {\n    load(DEFAULT_POSITION);\n  }\n\n  function load(fen, keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n\n    var tokens = fen.split(/\\s+/);\n    var position = tokens[0];\n    var square = 0;\n\n    if (!validate_fen(fen).valid) {\n      return validate_fen(fen);\n    }\n\n    clear(keep_headers);\n\n    for (var i = 0; i < position.length; i++) {\n      var piece = position.charAt(i);\n\n      if (piece === '/') {\n        square += 8;\n      } else if (is_digit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        var color = piece < 'a' ? WHITE : BLACK;\n        put({\n          type: piece.toLowerCase(),\n          color: color\n        }, algebraic(square));\n        square++;\n      }\n    }\n\n    turn = tokens[1];\n\n    if (tokens[2].indexOf('K') > -1) {\n      castling.w |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('Q') > -1) {\n      castling.w |= BITS.QSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('k') > -1) {\n      castling.b |= BITS.KSIDE_CASTLE;\n    }\n\n    if (tokens[2].indexOf('q') > -1) {\n      castling.b |= BITS.QSIDE_CASTLE;\n    }\n\n    ep_square = tokens[3] === '-' ? EMPTY : SQUARES[tokens[3]];\n    half_moves = parseInt(tokens[4], 10);\n    move_number = parseInt(tokens[5], 10);\n    update_setup(generate_fen());\n    return true;\n  }\n  /* TODO: this function is pretty much crap - it validates structure but\n   * completely ignores content (e.g. doesn't verify that each side has a king)\n   * ... we should rewrite this, and ditch the silly error_number field while\n   * we're at it\n   */\n\n\n  function validate_fen(fen) {\n    var errors = {\n      0: 'No errors.',\n      1: 'FEN string must contain six space-delimited fields.',\n      2: '6th field (move number) must be a positive integer.',\n      3: '5th field (half move counter) must be a non-negative integer.',\n      4: '4th field (en-passant square) is invalid.',\n      5: '3rd field (castling availability) is invalid.',\n      6: '2nd field (side to move) is invalid.',\n      7: '1st field (piece positions) does not contain 8 \\'/\\'-delimited rows.',\n      8: '1st field (piece positions) is invalid [consecutive numbers].',\n      9: '1st field (piece positions) is invalid [invalid piece].',\n      10: '1st field (piece positions) is invalid [row too large].',\n      11: 'Illegal en-passant square'\n    };\n    /* 1st criterion: 6 space-seperated fields? */\n\n    var tokens = fen.split(/\\s+/);\n\n    if (tokens.length !== 6) {\n      return {\n        valid: false,\n        error_number: 1,\n        error: errors[1]\n      };\n    }\n    /* 2nd criterion: move number field is a integer value > 0? */\n\n\n    if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\n      return {\n        valid: false,\n        error_number: 2,\n        error: errors[2]\n      };\n    }\n    /* 3rd criterion: half move counter is an integer >= 0? */\n\n\n    if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\n      return {\n        valid: false,\n        error_number: 3,\n        error: errors[3]\n      };\n    }\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n\n\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n      return {\n        valid: false,\n        error_number: 4,\n        error: errors[4]\n      };\n    }\n    /* 5th criterion: 3th field is a valid castle-string? */\n\n\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n      return {\n        valid: false,\n        error_number: 5,\n        error: errors[5]\n      };\n    }\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n\n\n    if (!/^(w|b)$/.test(tokens[1])) {\n      return {\n        valid: false,\n        error_number: 6,\n        error: errors[6]\n      };\n    }\n    /* 7th criterion: 1st field contains 8 rows? */\n\n\n    var rows = tokens[0].split('/');\n\n    if (rows.length !== 8) {\n      return {\n        valid: false,\n        error_number: 7,\n        error: errors[7]\n      };\n    }\n    /* 8th criterion: every row is valid? */\n\n\n    for (var i = 0; i < rows.length; i++) {\n      /* check for right sum of fields AND not two numbers in succession */\n      var sum_fields = 0;\n      var previous_was_number = false;\n\n      for (var k = 0; k < rows[i].length; k++) {\n        if (!isNaN(rows[i][k])) {\n          if (previous_was_number) {\n            return {\n              valid: false,\n              error_number: 8,\n              error: errors[8]\n            };\n          }\n\n          sum_fields += parseInt(rows[i][k], 10);\n          previous_was_number = true;\n        } else {\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n            return {\n              valid: false,\n              error_number: 9,\n              error: errors[9]\n            };\n          }\n\n          sum_fields += 1;\n          previous_was_number = false;\n        }\n      }\n\n      if (sum_fields !== 8) {\n        return {\n          valid: false,\n          error_number: 10,\n          error: errors[10]\n        };\n      }\n    }\n\n    if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n      return {\n        valid: false,\n        error_number: 11,\n        error: errors[11]\n      };\n    }\n    /* everything's okay! */\n\n\n    return {\n      valid: true,\n      error_number: 0,\n      error: errors[0]\n    };\n  }\n\n  function generate_fen() {\n    var empty = 0;\n    var fen = '';\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if (board[i] == null) {\n        empty++;\n      } else {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n\n        var color = board[i].color;\n        var piece = board[i].type;\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n      }\n\n      if (i + 1 & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n\n        if (i !== SQUARES.h1) {\n          fen += '/';\n        }\n\n        empty = 0;\n        i += 8;\n      }\n    }\n\n    var cflags = '';\n\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) {\n      cflags += 'K';\n    }\n\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) {\n      cflags += 'Q';\n    }\n\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) {\n      cflags += 'k';\n    }\n\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) {\n      cflags += 'q';\n    }\n    /* do we have an empty castling flag? */\n\n\n    cflags = cflags || '-';\n    var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square);\n    return [fen, turn, cflags, epflags, half_moves, move_number].join(' ');\n  }\n\n  function set_header(args) {\n    for (var i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        header[args[i]] = args[i + 1];\n      }\n    }\n\n    return header;\n  }\n  /* called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\n   * equal to the default position, the SetUp and FEN are deleted\n   * the setup is only updated if history.length is zero, ie moves haven't been\n   * made.\n   */\n\n\n  function update_setup(fen) {\n    if (history.length > 0) return;\n\n    if (fen !== DEFAULT_POSITION) {\n      header['SetUp'] = '1';\n      header['FEN'] = fen;\n    } else {\n      delete header['SetUp'];\n      delete header['FEN'];\n    }\n  }\n\n  function pawns() {\n    return board;\n  }\n\n  function get(square) {\n    var piece = board[SQUARES[square]];\n    return piece ? {\n      type: piece.type,\n      color: piece.color\n    } : null;\n  }\n\n  function put(piece, square) {\n    /* check for valid piece object */\n    if (!('type' in piece && 'color' in piece)) {\n      return false;\n    }\n    /* check for piece */\n\n\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n      return false;\n    }\n    /* check for valid square */\n\n\n    if (!(square in SQUARES)) {\n      return false;\n    }\n\n    var sq = SQUARES[square];\n    /* don't let the user place more than one king */\n\n    if (piece.type == KING && !(kings[piece.color] == EMPTY || kings[piece.color] == sq)) {\n      return false;\n    }\n\n    board[sq] = {\n      type: piece.type,\n      color: piece.color\n    };\n\n    if (piece.type === KING) {\n      kings[piece.color] = sq;\n    }\n\n    update_setup(generate_fen());\n    return true;\n  }\n\n  function remove(square) {\n    var piece = get(square);\n    board[SQUARES[square]] = null;\n\n    if (piece && piece.type === KING) {\n      kings[piece.color] = EMPTY;\n    }\n\n    update_setup(generate_fen());\n    return piece;\n  }\n\n  function build_move(board, from, to, flags, promotion) {\n    var move = {\n      color: turn,\n      from: from,\n      to: to,\n      flags: flags,\n      piece: board[from].type\n    };\n\n    if (promotion) {\n      move.flags |= BITS.PROMOTION; // move.flags = move.flags | BITS.PROMOTION\n\n      move.promotion = promotion;\n    }\n\n    if (board[to]) {\n      move.captured = board[to].type;\n    } else if (flags & BITS.EP_CAPTURE) {\n      move.captured = PAWN;\n    }\n\n    return move;\n  } // build_move()  from, to, piece and if it promotes or captures\n\n\n  function generate_moves(options) {\n    // generates legal or pseudolegal moves\n    function add_move(board, moves, from, to, flags) {\n      // pushes move (created using build_move) into the array\n\n      /* if pawn promotion */\n      if (board[from].type === PAWN && (rank(to) === RANK_8 || rank(to) === RANK_1)) {\n        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT];\n\n        for (var i = 0, len = pieces.length; i < len; i++) {\n          moves.push(build_move(board, from, to, flags, pieces[i]));\n        }\n      } else {\n        moves.push(build_move(board, from, to, flags));\n      }\n    }\n\n    var moves = [];\n    var us = turn; // turn might be affected by scope conflict\n\n    var them = swap_color(us); //\n\n    var second_rank = {\n      b: RANK_7,\n      w: RANK_2\n    };\n    var first_sq = SQUARES.a8;\n    var last_sq = SQUARES.h1;\n    var single_square = false; // why single_square logic\n\n    /* do we want legal moves? */\n\n    var legal = typeof options !== 'undefined' && 'legal' in options ? options.legal : true;\n    /* are we generating moves for a single square? */\n\n    if (typeof options !== 'undefined' && 'square' in options) {\n      if (options.square in SQUARES) {\n        first_sq = last_sq = SQUARES[options.square];\n        single_square = true;\n      } else {\n        /* invalid square */\n        return [];\n      }\n    } // Allow to add `defending moves` to compute the defencse of squares and pieces\n\n\n    var defending_allowed = typeof options !== 'undefined' && 'defending_allowed' in options ? options.defending_allowed : false;\n\n    for (var i = first_sq; i <= last_sq; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n\n      var piece = board[i];\n\n      if (piece == null || piece.color !== us) {\n        continue;\n      }\n\n      if (piece.type === PAWN) {\n        /* single square, non-capturing */\n        var square = i + PAWN_OFFSETS[us][0];\n\n        if (board[square] == null) {\n          add_move(board, moves, i, square, BITS.NORMAL);\n          /* double square */\n\n          var square = i + PAWN_OFFSETS[us][1];\n\n          if (second_rank[us] === rank(i) && board[square] == null) {\n            add_move(board, moves, i, square, BITS.BIG_PAWN);\n          }\n        }\n        /* pawn captures */\n\n\n        for (j = 2; j < 4; j++) {\n          var square = i + PAWN_OFFSETS[us][j];\n          if (square & 0x88) continue;\n\n          if (board[square] != null && board[square].color === them) {\n            add_move(board, moves, i, square, BITS.CAPTURE);\n          } else if (square === ep_square) {\n            add_move(board, moves, i, ep_square, BITS.EP_CAPTURE); // } else if (board[square] != null && board[square].color === us && defending_allowed) {\n          } else if (defending_allowed) {\n            console.log(SQUARES[square]);\n            add_move(board, moves, i, square, BITS.CAPTURE);\n          }\n        }\n      } else {\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n          var offset = PIECE_OFFSETS[piece.type][j];\n          var square = i;\n\n          while (true) {\n            square += offset;\n            if (square & 0x88) break;\n\n            if (board[square] == null) {\n              add_move(board, moves, i, square, BITS.NORMAL);\n            } else {\n              // if (board[square].color === us) break;\n              if (board[square].color === us) {\n                if (defending_allowed) {\n                  add_move(board, moves, i, square, BITS.CAPTURE);\n                }\n\n                break;\n              }\n\n              add_move(board, moves, i, square, BITS.CAPTURE);\n              break;\n            }\n            /* break, if knight or king */\n\n\n            if (piece.type === 'n' || piece.type === 'k') break;\n          }\n        }\n      } // other than pawn\n\n    }\n    /* check for castling if: a) we're generating all moves, or b) we're doing\n     * single square move generation on the king's square\n     */\n\n\n    if (!single_square || last_sq === kings[us]) {\n      /* king-side castling */\n      if (castling[us] & BITS.KSIDE_CASTLE) {\n        var castling_from = kings[us];\n        var castling_to = castling_from + 2;\n\n        if (board[castling_from + 1] == null && board[castling_to] == null && !attacked(them, kings[us]) && !attacked(them, castling_from + 1) && !attacked(them, castling_to)) {\n          add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE);\n        }\n      }\n      /* queen-side castling */\n\n\n      if (castling[us] & BITS.QSIDE_CASTLE) {\n        var castling_from = kings[us];\n        var castling_to = castling_from - 2;\n\n        if (board[castling_from - 1] == null && board[castling_from - 2] == null && board[castling_from - 3] == null && !attacked(them, kings[us]) && !attacked(them, castling_from - 1) && !attacked(them, castling_to)) {\n          add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE);\n        }\n      }\n    }\n    /* return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n\n\n    if (!legal) {\n      return moves;\n    }\n    /* filter out illegal moves */\n\n\n    var legal_moves = [];\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]); // make_move also used to find legal move\n\n      if (!king_attacked(us)) {\n        legal_moves.push(moves[i]);\n      }\n\n      undo_move();\n    }\n\n    return legal_moves; // legal move generation is also costly\n  } // generate_moves()\n\n\n  function swap_color_in_fen(remove_ep_field = false) {\n    // Ensure that the other color is active now\n    var tokens = generate_fen().split(/\\s+/);\n    tokens[1] = swap_color(tokens[1]);\n    if (remove_ep_field) tokens[3] = '-';\n    var new_fen = tokens.join(' ');\n    var r = load(new_fen); // console.log(r);\n  }\n  /*\n   * Returns a map with keys as all pieces (of the current color) and\n   * an array with defending pieces as value. If a piece is not defended,\n   * the array is empty\n   */\n\n\n  function defended_pieces(color_code = null, attack_square = false, remove_ep_field = false) {\n    var result = {}; // Fill the result with possibly defended pieces\n\n    var relevant_color;\n\n    if (color_code) {\n      relevant_color = color_code;\n    } else {\n      relevant_color = swap_color(turn);\n    }\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if (attack_square || board[i] && board[i].color === relevant_color) {\n        var defended = board[i] ? board[i].type : '';\n        var defended_field = algebraic(i);\n        result[defended + defended_field] = [];\n      }\n\n      if (i + 1 & 0x88) {\n        i += 8;\n      }\n    }\n\n    if (relevant_color !== turn) {\n      swap_color_in_fen(remove_ep_field);\n    } // Check now all moves (even illegal ones that defend a piece)\n\n\n    var moves = generate_moves({\n      defending_allowed: true,\n      legal: false\n    });\n\n    for (var index = 0; index < moves.length; index++) {\n      var move = moves[index];\n      var defended;\n\n      if (attack_square) {\n        defended = move.captured ? move.captured : '';\n      } else {\n        defended = move.captured;\n      }\n\n      if (move.flags & BITS.EP_CAPTURE) continue;\n      var field_to = algebraic(move.to); //console.log('Field to: ' + field_to);\n\n      if (attack_square || defended && get(field_to).color == relevant_color) {\n        var defender = move.piece;\n        var field_from = algebraic(move.from);\n        var val = defender + field_from;\n        var key = defended + field_to;\n        result[key].push(val);\n      }\n    }\n\n    return result;\n  }\n  /*\n   * Returns a map with keys as all pieces (of the current color) and\n   * an array with attacking pieces as value. If a piece is not attacked,\n   * the array is empty.\n   */\n\n\n  function attacked_pieces(color_code = null, attack_square = false) {\n    var result = {}; // Fill the result with possibly attacked pieces\n\n    var relevant_color;\n\n    if (color_code) {\n      relevant_color = color_code;\n    } else {\n      relevant_color = swap_color(turn);\n    }\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if (attack_square || board[i] && board[i].color === relevant_color) {\n        var attacked = board[i] ? board[i].type : '';\n        var attacked_field = algebraic(i);\n        result[attacked + attacked_field] = [];\n      }\n\n      if (i + 1 & 0x88) {\n        i += 8;\n      }\n    }\n\n    if (relevant_color === turn) {\n      swap_color_in_fen();\n    } // Check now for each possible move, if something is attacked\n\n\n    var moves = generate_moves();\n\n    for (var index = 0; index < moves.length; index++) {\n      var move = moves[index];\n      var attacked;\n\n      if (attack_square) {\n        attacked = move.captured ? move.captured : '';\n      } else {\n        attacked = move.captured;\n      }\n\n      if (attack_square || attacked) {\n        var attacker = move.piece;\n        var field_from = algebraic(move.from);\n        var val = attacker + field_from;\n        var field_to = algebraic(move.to);\n        var key = attacked + field_to;\n        if (result[key]) result[key].push(val);\n      }\n    }\n\n    return result;\n  }\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n   * disambiguation bugs in Fritz and Chessbase.  See below:\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n\n\n  function move_to_san(move, sloppy) {\n    var output = '';\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      var disambiguator = get_disambiguator(move, sloppy);\n\n      if (move.piece !== PAWN) {\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0];\n        }\n\n        output += 'x';\n      }\n\n      output += algebraic(move.to);\n\n      if (move.flags & BITS.PROMOTION) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n\n    make_move(move);\n\n    if (in_check()) {\n      if (in_checkmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n\n    undo_move();\n    return output;\n  } // parses all of the decorators out of a SAN string\n\n\n  function stripped_san(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n  }\n\n  function attacked(color, square) {\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      /* if empty square or wrong color */\n\n\n      if (board[i] == null || board[i].color !== color) continue;\n      var piece = board[i];\n      var difference = i - square;\n      var index = difference + 119;\n\n      if (ATTACKS[index] & 1 << SHIFTS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true;\n          } else {\n            if (piece.color === BLACK) return true;\n          }\n\n          continue;\n        }\n        /* if the piece is a knight or a king */\n\n\n        if (piece.type === 'n' || piece.type === 'k') return true;\n        var offset = RAYS[index];\n        var j = i + offset;\n        var blocked = false;\n\n        while (j !== square) {\n          if (board[j] != null) {\n            blocked = true;\n            break;\n          }\n\n          j += offset;\n        }\n\n        if (!blocked) return true;\n      }\n    }\n\n    return false;\n  }\n\n  function king_attacked(color) {\n    return attacked(swap_color(color), kings[color]);\n  }\n\n  function in_check() {\n    return king_attacked(turn);\n  }\n\n  function in_checkmate() {\n    return in_check() && generate_moves().length === 0;\n  }\n\n  function in_stalemate() {\n    return !in_check() && generate_moves().length === 0;\n  }\n\n  function insufficient_material() {\n    var pieces = {};\n    var bishops = [];\n    var num_pieces = 0;\n    var sq_color = 0;\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      sq_color = (sq_color + 1) % 2;\n\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n\n      var piece = board[i];\n\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n\n        if (piece.type === BISHOP) {\n          bishops.push(sq_color);\n        }\n\n        num_pieces++;\n      }\n    }\n    /* k vs. k */\n\n\n    if (num_pieces === 2) {\n      return true;\n    }\n    /* k vs. kn .... or .... k vs. kb */\n    else if (num_pieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n        return true;\n      }\n      /* kb vs. kb where any number of bishops are all on the same color */\n      else if (num_pieces === pieces[BISHOP] + 2) {\n          var sum = 0;\n          var len = bishops.length;\n\n          for (var i = 0; i < len; i++) {\n            sum += bishops[i];\n          }\n\n          if (sum === 0 || sum === len) {\n            return true;\n          }\n        }\n\n    return false;\n  }\n\n  function in_threefold_repetition() {\n    /* TODO: while this function is fine for casual use, a better\n     * implementation would use a Zobrist key (instead of FEN). the\n     * Zobrist key would be maintained in the make_move/undo_move functions,\n     * avoiding the costly that we do below.\n     */\n    var moves = [];\n    var positions = {};\n    var repetition = false;\n\n    while (true) {\n      var move = undo_move();\n      if (!move) break;\n      moves.push(move);\n    }\n\n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\n       * when checking for draw by rep */\n      var fen = generate_fen().split(' ').slice(0, 4).join(' ');\n      /* has the position occurred three or move times */\n\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n\n      if (positions[fen] >= 3) {\n        repetition = true;\n      }\n\n      if (!moves.length) {\n        break;\n      }\n\n      make_move(moves.pop());\n    }\n\n    return repetition;\n  }\n\n  function push(move) {\n    history.push({\n      move: move,\n      kings: {\n        b: kings.b,\n        w: kings.w\n      },\n      turn: turn,\n      castling: {\n        b: castling.b,\n        w: castling.w\n      },\n      ep_square: ep_square,\n      half_moves: half_moves,\n      move_number: move_number\n    });\n  }\n\n  function make_move(move) {\n    var us = turn;\n    var them = swap_color(us);\n    push(move);\n    board[move.to] = board[move.from];\n    board[move.from] = null;\n    /* if ep capture, remove the captured pawn */\n\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (turn === BLACK) {\n        board[move.to - 16] = null;\n      } else {\n        board[move.to + 16] = null;\n      }\n    }\n    /* if pawn promotion, replace with new piece */\n\n\n    if (move.flags & BITS.PROMOTION) {\n      board[move.to] = {\n        type: move.promotion,\n        color: us\n      };\n    }\n    /* if we moved the king */\n\n\n    if (board[move.to].type === KING) {\n      kings[board[move.to].color] = move.to;\n      /* if we castled, move the rook next to the king */\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        var castling_to = move.to - 1;\n        var castling_from = move.to + 1;\n        board[castling_to] = board[castling_from];\n        board[castling_from] = null;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        var castling_to = move.to + 1;\n        var castling_from = move.to - 2;\n        board[castling_to] = board[castling_from];\n        board[castling_from] = null;\n      }\n      /* turn off castling */\n\n\n      castling[us] = '';\n    }\n    /* turn off castling if we move a rook */\n\n\n    if (castling[us]) {\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square && castling[us] & ROOKS[us][i].flag) {\n          castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    }\n    /* turn off castling if we capture a rook */\n\n\n    if (castling[them]) {\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square && castling[them] & ROOKS[them][i].flag) {\n          castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    }\n    /* if big pawn move, update the en passant square */\n\n\n    if (move.flags & BITS.BIG_PAWN) {\n      if (turn === 'b') {\n        ep_square = move.to - 16;\n      } else {\n        ep_square = move.to + 16;\n      }\n    } else {\n      ep_square = EMPTY;\n    }\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n\n\n    if (move.piece === PAWN) {\n      half_moves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      half_moves = 0;\n    } else {\n      half_moves++;\n    }\n\n    if (turn === BLACK) {\n      move_number++;\n    }\n\n    turn = swap_color(turn);\n  }\n\n  function undo_move() {\n    var old = history.pop();\n\n    if (old == null) {\n      return null;\n    }\n\n    var move = old.move;\n    kings = old.kings;\n    turn = old.turn;\n    castling = old.castling;\n    ep_square = old.ep_square;\n    half_moves = old.half_moves;\n    move_number = old.move_number;\n    var us = turn;\n    var them = swap_color(turn);\n    board[move.from] = board[move.to];\n    board[move.from].type = move.piece; // to undo any promotions\n\n    board[move.to] = null;\n\n    if (move.flags & BITS.CAPTURE) {\n      board[move.to] = {\n        type: move.captured,\n        color: them\n      };\n    } else if (move.flags & BITS.EP_CAPTURE) {\n      var index;\n\n      if (us === BLACK) {\n        index = move.to - 16;\n      } else {\n        index = move.to + 16;\n      }\n\n      board[index] = {\n        type: PAWN,\n        color: them\n      };\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      var castling_to, castling_from;\n\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castling_to = move.to + 1;\n        castling_from = move.to - 1;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        castling_to = move.to - 2;\n        castling_from = move.to + 1;\n      }\n\n      board[castling_to] = board[castling_from];\n      board[castling_from] = null;\n    }\n\n    return move;\n  }\n  /* this function is used to uniquely identify ambiguous moves */\n\n\n  function get_disambiguator(move, sloppy) {\n    var moves = generate_moves({\n      legal: !sloppy\n    });\n    var from = move.from;\n    var to = move.to;\n    var piece = move.piece;\n    var ambiguities = 0;\n    var same_rank = 0;\n    var same_file = 0;\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      var ambig_from = moves[i].from;\n      var ambig_to = moves[i].to;\n      var ambig_piece = moves[i].piece;\n      /* if a move of the same piece type ends on the same to square, we'll\n       * need to add a disambiguator to the algebraic notation\n       */\n\n      if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n        ambiguities++;\n\n        if (rank(from) === rank(ambig_from)) {\n          same_rank++;\n        }\n\n        if (file(from) === file(ambig_from)) {\n          same_file++;\n        }\n      }\n    }\n\n    if (ambiguities > 0) {\n      /* if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      if (same_rank > 0 && same_file > 0) {\n        return algebraic(from);\n      }\n      /* if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      else if (same_file > 0) {\n          return algebraic(from).charAt(1);\n        }\n        /* else use the file symbol */\n        else {\n            return algebraic(from).charAt(0);\n          }\n    }\n\n    return '';\n  }\n\n  function ascii() {\n    var s = '   +------------------------+\\n';\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* display the rank */\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |';\n      }\n      /* empty piece */\n\n\n      if (board[i] == null) {\n        s += ' . ';\n      } else {\n        var piece = board[i].type;\n        var color = board[i].color;\n        var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        s += ' ' + symbol + ' ';\n      }\n\n      if (i + 1 & 0x88) {\n        s += '|\\n';\n        i += 8;\n      }\n    }\n\n    s += '   +------------------------+\\n';\n    s += '     a  b  c  d  e  f  g  h\\n';\n    return s;\n  } // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n\n\n  function move_from_san(move, sloppy) {\n    // strip off any move decorations: e.g Nf3+?!\n    var clean_move = stripped_san(move); // if we're using the sloppy parser run a regex to grab piece, to, and from\n    // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\n\n    if (sloppy) {\n      var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n\n      if (matches) {\n        var piece = matches[1];\n        var from = matches[2];\n        var to = matches[3];\n        var promotion = matches[4];\n      }\n    }\n\n    var moves = generate_moves();\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      // try the strict parser first, then the sloppy parser if requested\n      // by the user\n      if (clean_move === stripped_san(move_to_san(moves[i])) || sloppy && clean_move === stripped_san(move_to_san(moves[i], true))) {\n        fen_history.push(generate_fen()); //fen_history\n\n        return moves[i];\n      } else {\n        if (matches && (!piece || piece.toLowerCase() == moves[i].piece) && SQUARES[from] == moves[i].from && SQUARES[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n          return moves[i];\n        }\n      }\n    }\n\n    return null;\n  } // move_from_san\n\n  /*****************************************************************************\n   * UTILITY FUNCTIONS\n   ****************************************************************************/\n\n\n  function rank(i) {\n    return i >> 4;\n  }\n\n  function file(i) {\n    return i & 15;\n  }\n\n  function algebraic(i) {\n    var f = file(i),\n        r = rank(i);\n    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n  }\n\n  function swap_color(c) {\n    return c === WHITE ? BLACK : WHITE;\n  }\n\n  function is_digit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n  }\n  /* pretty = external move object */\n\n\n  function make_pretty(ugly_move) {\n    var move = clone(ugly_move);\n    move.san = move_to_san(move, false);\n    move.to = algebraic(move.to);\n    move.from = algebraic(move.from);\n    var flags = '';\n\n    for (var flag in BITS) {\n      if (BITS[flag] & move.flags) {\n        flags += FLAGS[flag];\n      }\n    }\n\n    move.flags = flags;\n    return move;\n  }\n\n  function clone(obj) {\n    var dupe = obj instanceof Array ? [] : {};\n\n    for (var property in obj) {\n      if (typeof property === 'object') {\n        dupe[property] = clone(obj[property]);\n      } else {\n        dupe[property] = obj[property];\n      }\n    }\n\n    return dupe;\n  }\n\n  function trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n  }\n  /*****************************************************************************\n   * DEBUGGING UTILITIES\n   ****************************************************************************/\n\n\n  function perft(depth) {\n    var moves = generate_moves({\n      legal: false\n    });\n    var nodes = 0;\n    var color = turn;\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]);\n\n      if (!king_attacked(color)) {\n        if (depth - 1 > 0) {\n          var child_nodes = perft(depth - 1);\n          nodes += child_nodes;\n        } else {\n          nodes++;\n        }\n      }\n\n      undo_move();\n    }\n\n    return nodes;\n  }\n\n  return {\n    /***************************************************************************\n     * PUBLIC CONSTANTS (is there a better way to do this?)\n     **************************************************************************/\n    WHITE: WHITE,\n    BLACK: BLACK,\n    PAWN: PAWN,\n    KNIGHT: KNIGHT,\n    BISHOP: BISHOP,\n    ROOK: ROOK,\n    QUEEN: QUEEN,\n    KING: KING,\n    SQUARES: function () {\n      /* from the ECMA-262 spec (section 12.6.4):\n       * \"The mechanics of enumerating the properties ... is\n       * implementation dependent\"\n       * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n       * ordered correctly\n       */\n      var keys = [];\n\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (i & 0x88) {\n          i += 7;\n          continue;\n        }\n\n        keys.push(algebraic(i));\n      }\n\n      return keys;\n    }(),\n    FLAGS: FLAGS,\n\n    /***************************************************************************\n     * PUBLIC API\n     **************************************************************************/\n    load: function (fen) {\n      return load(fen);\n    },\n    reset: function () {\n      return reset();\n    },\n    moves: function (options) {\n      /* The internal representation of a chess move is in 0x88 format, and\n       * not meant to be human-readable.  The code below converts the 0x88\n       * square coordinates to algebraic coordinates.  It also prunes an\n       * unnecessary move keys resulting from a verbose call.\n       */\n      var ugly_moves = generate_moves(options);\n      var moves = [];\n\n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\n        /* does the user want a full move object (most likely not), or just\n         * SAN\n         */\n        if (typeof options !== 'undefined' && 'verbose' in options && options.verbose) {\n          moves.push(make_pretty(ugly_moves[i]));\n        } else {\n          moves.push(move_to_san(ugly_moves[i], false));\n        }\n      }\n\n      return moves;\n    },\n    defended_pieces: function (color_code, attack_square, remove_ep_field) {\n      return defended_pieces(color_code, attack_square, remove_ep_field);\n    },\n    attacked_pieces: function (color_code, attack_square) {\n      return attacked_pieces(color_code, attack_square);\n    },\n    in_check: function () {\n      return in_check();\n    },\n    in_checkmate: function () {\n      return in_checkmate();\n    },\n    in_stalemate: function () {\n      return in_stalemate();\n    },\n    in_draw: function () {\n      return half_moves >= 100 || in_stalemate() || insufficient_material() || in_threefold_repetition();\n    },\n    insufficient_material: function () {\n      return insufficient_material();\n    },\n    in_threefold_repetition: function () {\n      return in_threefold_repetition();\n    },\n    game_over: function () {\n      return half_moves >= 100 || in_checkmate() || in_stalemate() || insufficient_material() || in_threefold_repetition();\n    },\n    validate_fen: function (fen) {\n      return validate_fen(fen);\n    },\n    fen: function () {\n      return generate_fen();\n    },\n    board: function () {\n      var output = [],\n          row = [];\n\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (board[i] == null) {\n          row.push(null);\n        } else {\n          row.push({\n            type: board[i].type,\n            color: board[i].color\n          });\n        }\n\n        if (i + 1 & 0x88) {\n          output.push(row);\n          row = [];\n          i += 8;\n        }\n      }\n\n      return output;\n    },\n    pawns: function () {\n      return pawns.map((e, i) => {});\n    },\n    pgn: function (options) {\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var newline = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\n';\n      var max_width = typeof options === 'object' && typeof options.max_width === 'number' ? options.max_width : 0;\n      var result = [];\n      var header_exists = false;\n      /* add the PGN header headerrmation */\n\n      for (var i in header) {\n        /* TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \\\"' + header[i] + '\\\"]' + newline);\n        header_exists = true;\n      }\n\n      if (header_exists && history.length) {\n        result.push(newline);\n      }\n      /* pop all of history onto reversed_history */\n\n\n      var reversed_history = [];\n\n      while (history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n\n      var moves = [];\n      var move_string = '';\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop();\n        /* if the position started with black to move, start PGN with 1. ... */\n\n        if (!history.length && move.color === 'b') {\n          move_string = move_number + '. ...';\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (move_string.length) {\n            moves.push(move_string);\n          }\n\n          move_string = move_number + '.';\n        }\n\n        move_string = move_string + ' ' + move_to_san(move, false);\n        make_move(move);\n      }\n      /* are there any other leftover moves? */\n\n\n      if (move_string.length) {\n        moves.push(move_string);\n      }\n      /* is there a result? */\n\n\n      if (typeof header.Result !== 'undefined') {\n        moves.push(header.Result);\n      }\n      /* history should be back to what is was before we started generating PGN,\n       * so join together moves\n       */\n\n\n      if (max_width === 0) {\n        return result.join('') + moves.join(' ');\n      }\n      /* wrap the PGN output at max_width */\n\n\n      var current_width = 0;\n\n      for (var i = 0; i < moves.length; i++) {\n        /* if the current move will push past max_width */\n        if (current_width + moves[i].length > max_width && i !== 0) {\n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop();\n          }\n\n          result.push(newline);\n          current_width = 0;\n        } else if (i !== 0) {\n          result.push(' ');\n          current_width++;\n        }\n\n        result.push(moves[i]);\n        current_width += moves[i].length;\n      }\n\n      return result.join('');\n    },\n    //pgn()\n    load_pgn: function (pgn, options) {\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = typeof options !== 'undefined' && 'sloppy' in options ? options.sloppy : false;\n\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\');\n      }\n\n      function has_keys(object) {\n        for (var key in object) {\n          return true;\n        }\n\n        return false;\n      }\n\n      function parse_pgn_header(header, options) {\n        var newline_char = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\r?\\n';\n        var header_obj = {};\n        var headers = header.split(new RegExp(mask(newline_char)));\n        var key = '';\n        var value = '';\n\n        for (var i = 0; i < headers.length; i++) {\n          key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1');\n          value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\]$/, '$1');\n\n          if (trim(key).length > 0) {\n            header_obj[key] = value;\n          }\n        }\n\n        return header_obj;\n      } // parse_pgn_header\n\n\n      var newline_char = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\r?\\n'; // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n\n      var header_regex = new RegExp('^(\\\\[((?:' + mask(newline_char) + ')|.)*\\\\])' + '(?:' + mask(newline_char) + '){2}'); // If no header given, begin with moves.\n\n      var header_string = header_regex.test(pgn) ? header_regex.exec(pgn)[1] : ''; // Put the board in the starting position\n\n      reset();\n      /* parse PGN header */\n\n      var headers = parse_pgn_header(header_string, options);\n\n      for (var key in headers) {\n        set_header([key, headers[key]]);\n      }\n      /* load the starting position indicated by [Setup '1'] and\n      * [FEN position] */\n\n\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers && load(headers['FEN'], true))) {\n          // second argument to load: don't clear the headers\n          return false;\n        }\n      }\n      /* delete header to get the moves */\n\n\n      var ms = pgn.replace(header_string, '').replace(new RegExp(mask(newline_char), 'g'), ' ');\n      /* delete comments */\n\n      ms = ms.replace(/(\\{[^}]+\\})+?/g, '');\n      /* delete recursive annotation variations */\n\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g;\n\n      while (rav_regex.test(ms)) {\n        ms = ms.replace(rav_regex, '');\n      }\n      /* delete move numbers */\n\n\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n      /* delete ... indicating black to move */\n\n      ms = ms.replace(/\\.\\.\\./g, '');\n      /* delete numeric annotation glyphs */\n\n      ms = ms.replace(/\\$\\d+/g, '');\n      /* trim and get array of moves */\n\n      var moves = trim(ms).split(new RegExp(/\\s+/));\n      /* delete empty entries */\n\n      moves = moves.join(',').replace(/,,+/g, ',').split(',');\n      var move = '';\n\n      for (var half_move = 0; half_move < moves.length - 1; half_move++) {\n        move = move_from_san(moves[half_move], sloppy);\n        /* move not possible! (don't clear the board to examine to show the\n         * latest valid position)\n         */\n\n        if (move == null) {\n          return false;\n        } else {\n          make_move(move);\n        }\n      }\n      /* examine last move */\n\n\n      move = moves[moves.length - 1];\n\n      if (POSSIBLE_RESULTS.indexOf(move) > -1) {\n        if (has_keys(header) && typeof header.Result === 'undefined') {\n          set_header(['Result', move]);\n        }\n      } else {\n        move = move_from_san(move, sloppy);\n\n        if (move == null) {\n          return false;\n        } else {\n          make_move(move);\n        }\n      }\n\n      return true;\n    },\n    // load_pgn()\n    header: function () {\n      return set_header(arguments);\n    },\n    ascii: function () {\n      return ascii();\n    },\n    turn: function () {\n      return turn;\n    },\n    move: function (move, options) {\n      /* The move function can be called with in the following parameters:\n       *\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n       *\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\n       *         to :'h8',      fields are ignored)\n       *         promotion: 'q',\n       *      })\n       */\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = typeof options !== 'undefined' && 'sloppy' in options ? options.sloppy : false;\n      var move_obj = null;\n\n      if (typeof move === 'string') {\n        move_obj = move_from_san(move, sloppy);\n      } else if (typeof move === 'object') {\n        var moves = generate_moves();\n        /* convert the pretty move object to an ugly move object */\n\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n            move_obj = moves[i];\n            break;\n          }\n        }\n      }\n      /* failed to find move */\n\n\n      if (!move_obj) {\n        return null;\n      }\n      /* need to make a copy of move because we can't generate SAN after the\n       * move is made\n       */\n\n\n      var pretty_move = make_pretty(move_obj);\n      make_move(move_obj);\n      return pretty_move;\n    },\n    undo: function () {\n      var move = undo_move();\n      return move ? make_pretty(move) : null;\n    },\n    clear: function () {\n      return clear();\n    },\n    put: function (piece, square) {\n      return put(piece, square);\n    },\n    get: function (square) {\n      return get(square);\n    },\n    remove: function (square) {\n      return remove(square);\n    },\n    perft: function (depth) {\n      return perft(depth);\n    },\n    square_color: function (square) {\n      if (square in SQUARES) {\n        var sq_0x88 = SQUARES[square];\n        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark';\n      }\n\n      return null;\n    },\n    history: function (options) {\n      var reversed_history = [];\n      var move_history = [];\n      var verbose = typeof options !== 'undefined' && 'verbose' in options && options.verbose;\n\n      while (history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop();\n\n        if (verbose) {\n          move_history.push(make_pretty(move));\n        } else {\n          move_history.push(move_to_san(move));\n        }\n\n        make_move(move);\n      }\n\n      return move_history;\n    },\n    // history()\n    nextmv: function () {\n      if (fen_history.length > 0) {\n        if (fh_curr > fen_history.length - 2) {\n          load(fen_history[0]);\n        } else {\n          load(fen_history[fh_curr]);\n          fh_curr++;\n        }\n      }\n    },\n    prevmv: function () {\n      if (fen_history.length > 0) {\n        if (fh_curr < 1) {\n          load(fen_history[fen_history.length - 1]);\n        } else {\n          load(fen_history[fh_curr]);\n          fh_curr--;\n        }\n      }\n    }\n  }; //closure object\n};\n/* export Chess object if using node or any other CommonJS compatible\n * environment */\n\n\nif (typeof exports !== 'undefined') exports.Chess = Chess;\n/* export Chess object for any RequireJS compatible environment */\n\nif (typeof define !== 'undefined') define(function () {\n  return Chess;\n});","map":{"version":3,"sources":["/Users/q/Documents/WebDocuments/chess/node_modules/chess.js/chess.js"],"names":["Chess","fen","BLACK","WHITE","EMPTY","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","SYMBOLS","DEFAULT_POSITION","POSSIBLE_RESULTS","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","SHIFTS","p","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","RANK_1","RANK_2","RANK_3","RANK_4","RANK_5","RANK_6","RANK_7","RANK_8","SQUARES","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","ROOKS","square","flag","board","Array","kings","turn","castling","ep_square","half_moves","move_number","history","header","fen_history","fh_curr","load","clear","keep_headers","update_setup","generate_fen","reset","tokens","split","position","validate_fen","valid","i","length","piece","charAt","is_digit","parseInt","color","put","type","toLowerCase","algebraic","indexOf","errors","error_number","error","isNaN","test","rows","sum_fields","previous_was_number","empty","toUpperCase","cflags","epflags","join","set_header","args","pawns","get","sq","remove","build_move","from","to","flags","promotion","move","captured","generate_moves","options","add_move","moves","rank","pieces","len","push","us","them","swap_color","second_rank","first_sq","last_sq","single_square","legal","defending_allowed","j","console","log","offset","castling_from","castling_to","attacked","legal_moves","make_move","king_attacked","undo_move","swap_color_in_fen","remove_ep_field","new_fen","defended_pieces","color_code","attack_square","result","relevant_color","defended","defended_field","index","field_to","defender","field_from","val","key","attacked_pieces","attacked_field","attacker","move_to_san","sloppy","output","disambiguator","get_disambiguator","in_check","in_checkmate","stripped_san","replace","difference","blocked","in_stalemate","insufficient_material","bishops","num_pieces","sq_color","sum","in_threefold_repetition","positions","repetition","slice","pop","old","ambiguities","same_rank","same_file","ambig_from","ambig_to","ambig_piece","file","ascii","s","symbol","move_from_san","clean_move","matches","match","f","substring","c","make_pretty","ugly_move","clone","san","obj","dupe","property","trim","str","perft","depth","nodes","child_nodes","keys","ugly_moves","verbose","in_draw","game_over","row","map","e","pgn","newline","newline_char","max_width","header_exists","reversed_history","move_string","Result","current_width","load_pgn","mask","has_keys","object","parse_pgn_header","header_obj","headers","RegExp","value","header_regex","header_string","exec","ms","rav_regex","half_move","arguments","move_obj","pretty_move","undo","square_color","sq_0x88","move_history","nextmv","prevmv","exports","define"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\n \n/* minified license below  */\n \n/* @license\n * Copyright (c) 2017, Jeff Hlywa (jhlywa@gmail.com)\n * Released under the BSD license\n * https://github.com/jhlywa/chess.js/blob/master/LICENSE\n */\n \nvar Chess = function(fen) {  // funciton returns a closure object\n \n  /* jshint indent: false */\n \n  var BLACK = 'b';\n  var WHITE = 'w';\n \n  var EMPTY = -1;\n \n  var PAWN = 'p';\n  var KNIGHT = 'n';\n  var BISHOP = 'b';\n  var ROOK = 'r';\n  var QUEEN = 'q';\n  var KING = 'k';\n \n  var SYMBOLS = 'pnbrqkPNBRQK';\n \n  var DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\n \n  var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*'];\n \n  var PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15]\n  };\n \n  var PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14,  18, 33, 31,  14],\n    b: [-17, -15,  17,  15],\n    r: [-16,   1,  16,  -1],\n    q: [-17, -16, -15,   1,  17, 16, 15,  -1],\n    k: [-17, -16, -15,   1,  17, 16, 15,  -1]\n  };\n \n  var ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n  ];\n \n  var RAYS = [\n     17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n      0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n      0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n      0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n      0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n      1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n      0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n      0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n      0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n      0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n    -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n  ];\n \n  var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 };\n \n  var FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q'\n  };\n \n  var BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64\n  };\n \n  var RANK_1 = 7;\n  var RANK_2 = 6;\n  var RANK_3 = 5;\n  var RANK_4 = 4;\n  var RANK_5 = 3;\n  var RANK_6 = 2;\n  var RANK_7 = 1;\n  var RANK_8 = 0;\n \n  var SQUARES = {\n    a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n    a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n    a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n    a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n    a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n    a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n    a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n  };\n \n  var ROOKS = {\n    w: [{square: SQUARES.a1, flag: BITS.QSIDE_CASTLE},\n        {square: SQUARES.h1, flag: BITS.KSIDE_CASTLE}],\n    b: [{square: SQUARES.a8, flag: BITS.QSIDE_CASTLE},\n        {square: SQUARES.h8, flag: BITS.KSIDE_CASTLE}]\n  };\n \n  var board = new Array(128);\n  var kings = {w: EMPTY, b: EMPTY};\n  var turn = WHITE;\n  var castling = {w: 0, b: 0};\n  var ep_square = EMPTY;\n  var half_moves = 0;\n  var move_number = 1;\n  var history = [];\n  var header = {};\n  var fen_history = [];\n  var fh_curr = 0;\n \n  /* if the user passes in a fen string, load it, else default to\n   * starting position\n   */\n  if (typeof fen === 'undefined') {\n    load(DEFAULT_POSITION);\n  } else {\n    load(fen);\n  }\n \n  function clear(keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n \n    board = new Array(128);\n    kings = {w: EMPTY, b: EMPTY};\n    turn = WHITE;\n    castling = {w: 0, b: 0};\n    ep_square = EMPTY;\n    half_moves = 0;\n    move_number = 1;\n    history = [];\n    if (!keep_headers) header = {};\n    update_setup(generate_fen());\n  }\n \n  function reset() {\n    load(DEFAULT_POSITION);\n  }\n \n  function load(fen, keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n \n    var tokens = fen.split(/\\s+/);\n    var position = tokens[0];\n    var square = 0;\n \n    if (!validate_fen(fen).valid) {\n      return validate_fen(fen);\n    }\n \n    clear(keep_headers);\n \n    for (var i = 0; i < position.length; i++) {\n      var piece = position.charAt(i);\n \n      if (piece === '/') {\n        square += 8;\n      } else if (is_digit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        var color = (piece < 'a') ? WHITE : BLACK;\n        put({type: piece.toLowerCase(), color: color}, algebraic(square));\n        square++;\n      }\n    }\n \n    turn = tokens[1];\n \n    if (tokens[2].indexOf('K') > -1) {\n      castling.w |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      castling.w |= BITS.QSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      castling.b |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      castling.b |= BITS.QSIDE_CASTLE;\n    }\n \n    ep_square = (tokens[3] === '-') ? EMPTY : SQUARES[tokens[3]];\n    half_moves = parseInt(tokens[4], 10);\n    move_number = parseInt(tokens[5], 10);\n \n    update_setup(generate_fen());\n \n    return true;\n  }\n \n  /* TODO: this function is pretty much crap - it validates structure but\n   * completely ignores content (e.g. doesn't verify that each side has a king)\n   * ... we should rewrite this, and ditch the silly error_number field while\n   * we're at it\n   */\n  function validate_fen(fen) {\n    var errors = {\n       0: 'No errors.',\n       1: 'FEN string must contain six space-delimited fields.',\n       2: '6th field (move number) must be a positive integer.',\n       3: '5th field (half move counter) must be a non-negative integer.',\n       4: '4th field (en-passant square) is invalid.',\n       5: '3rd field (castling availability) is invalid.',\n       6: '2nd field (side to move) is invalid.',\n       7: '1st field (piece positions) does not contain 8 \\'/\\'-delimited rows.',\n       8: '1st field (piece positions) is invalid [consecutive numbers].',\n       9: '1st field (piece positions) is invalid [invalid piece].',\n      10: '1st field (piece positions) is invalid [row too large].',\n      11: 'Illegal en-passant square',\n    };\n \n    /* 1st criterion: 6 space-seperated fields? */\n    var tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n      return {valid: false, error_number: 1, error: errors[1]};\n    }\n \n    /* 2nd criterion: move number field is a integer value > 0? */\n    if (isNaN(tokens[5]) || (parseInt(tokens[5], 10) <= 0)) {\n      return {valid: false, error_number: 2, error: errors[2]};\n    }\n \n    /* 3rd criterion: half move counter is an integer >= 0? */\n    if (isNaN(tokens[4]) || (parseInt(tokens[4], 10) < 0)) {\n      return {valid: false, error_number: 3, error: errors[3]};\n    }\n \n    /* 4th criterion: 4th field is a valid e.p.-string? */\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n      return {valid: false, error_number: 4, error: errors[4]};\n    }\n \n    /* 5th criterion: 3th field is a valid castle-string? */\n    if( !/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n      return {valid: false, error_number: 5, error: errors[5]};\n    }\n \n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n    if (!/^(w|b)$/.test(tokens[1])) {\n      return {valid: false, error_number: 6, error: errors[6]};\n    }\n \n    /* 7th criterion: 1st field contains 8 rows? */\n    var rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n      return {valid: false, error_number: 7, error: errors[7]};\n    }\n \n    /* 8th criterion: every row is valid? */\n    for (var i = 0; i < rows.length; i++) {\n      /* check for right sum of fields AND not two numbers in succession */\n      var sum_fields = 0;\n      var previous_was_number = false;\n \n      for (var k = 0; k < rows[i].length; k++) {\n        if (!isNaN(rows[i][k])) {\n          if (previous_was_number) {\n            return {valid: false, error_number: 8, error: errors[8]};\n          }\n          sum_fields += parseInt(rows[i][k], 10);\n          previous_was_number = true;\n        } else {\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n            return {valid: false, error_number: 9, error: errors[9]};\n          }\n          sum_fields += 1;\n          previous_was_number = false;\n        }\n      }\n      if (sum_fields !== 8) {\n        return {valid: false, error_number: 10, error: errors[10]};\n      }\n    }\n \n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n          return {valid: false, error_number: 11, error: errors[11]};\n    }\n \n    /* everything's okay! */\n    return {valid: true, error_number: 0, error: errors[0]};\n  }\n \n  function generate_fen() {\n    var empty = 0;\n    var fen = '';\n \n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if (board[i] == null) {\n        empty++;\n      } else {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        var color = board[i].color;\n        var piece = board[i].type;\n \n        fen += (color === WHITE) ?\n                 piece.toUpperCase() : piece.toLowerCase();\n      }\n \n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n \n        if (i !== SQUARES.h1) {\n          fen += '/';\n        }\n \n        empty = 0;\n        i += 8;\n      }\n    }\n \n    var cflags = '';\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) { cflags += 'K'; }\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) { cflags += 'Q'; }\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) { cflags += 'k'; }\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) { cflags += 'q'; }\n \n    /* do we have an empty castling flag? */\n    cflags = cflags || '-';\n    var epflags = (ep_square === EMPTY) ? '-' : algebraic(ep_square);\n \n    return [fen, turn, cflags, epflags, half_moves, move_number].join(' ');\n  }\n \n  function set_header(args) {\n    for (var i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' &&\n          typeof args[i + 1] === 'string') {\n        header[args[i]] = args[i + 1];\n      }\n    }\n    return header;\n  }\n \n  /* called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\n   * equal to the default position, the SetUp and FEN are deleted\n   * the setup is only updated if history.length is zero, ie moves haven't been\n   * made.\n   */\n  function update_setup(fen) {\n    if (history.length > 0) return;\n \n    if (fen !== DEFAULT_POSITION) {\n      header['SetUp'] = '1';\n      header['FEN'] = fen;\n    } else {\n      delete header['SetUp'];\n      delete header['FEN'];\n    }\n  }\n \n  function pawns(){\n    return board;\n  }\n\n  function get(square) {\n    var piece = board[SQUARES[square]];\n    return (piece) ? {type: piece.type, color: piece.color} : null;\n  }\n \n  function put(piece, square) {\n    /* check for valid piece object */\n    if (!('type' in piece && 'color' in piece)) {\n      return false;\n    }\n \n    /* check for piece */\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n      return false;\n    }\n \n    /* check for valid square */\n    if (!(square in SQUARES)) {\n      return false;\n    }\n \n    var sq = SQUARES[square];\n \n    /* don't let the user place more than one king */\n    if (piece.type == KING &&\n        !(kings[piece.color] == EMPTY || kings[piece.color] == sq)) {\n      return false;\n    }\n \n    board[sq] = {type: piece.type, color: piece.color};\n    if (piece.type === KING) {\n      kings[piece.color] = sq;\n    }\n \n    update_setup(generate_fen());\n \n    return true;\n  }\n \n  function remove(square) {\n    var piece = get(square);\n    board[SQUARES[square]] = null;\n    if (piece && piece.type === KING) {\n      kings[piece.color] = EMPTY;\n    }\n \n    update_setup(generate_fen());\n \n    return piece;\n  }\n \n  function build_move(board, from, to, flags, promotion) {\n    var move = {\n      color: turn,\n      from: from,\n      to: to,\n      flags: flags,\n      piece: board[from].type\n    };\n \n    if (promotion) {\n      move.flags |= BITS.PROMOTION;    // move.flags = move.flags | BITS.PROMOTION\n      move.promotion = promotion;\n    }\n \n    if (board[to]) {\n      move.captured = board[to].type;\n    } else if (flags & BITS.EP_CAPTURE) {\n        move.captured = PAWN;\n    }\n    return move;\n  } // build_move()  from, to, piece and if it promotes or captures\n \n  function generate_moves(options) {  // generates legal or pseudolegal moves\n    function add_move(board, moves, from, to, flags) {  // pushes move (created using build_move) into the array\n      /* if pawn promotion */\n      if (board[from].type === PAWN &&\n         (rank(to) === RANK_8 || rank(to) === RANK_1)) {\n          var pieces = [QUEEN, ROOK, BISHOP, KNIGHT];\n          for (var i = 0, len = pieces.length; i < len; i++) {\n            moves.push(build_move(board, from, to, flags, pieces[i]));\n          }\n      } else {\n       moves.push(build_move(board, from, to, flags));\n      }\n    }\n \n    var moves = [];\n    var us = turn;  // turn might be affected by scope conflict\n    var them = swap_color(us);  //\n    var second_rank = {b: RANK_7, w: RANK_2};\n \n    var first_sq = SQUARES.a8;\n    var last_sq = SQUARES.h1;\n    var single_square = false;   // why single_square logic\n \n    /* do we want legal moves? */\n    var legal = (typeof options !== 'undefined' && 'legal' in options) ?\n                options.legal : true;\n \n    /* are we generating moves for a single square? */\n    if (typeof options !== 'undefined' && 'square' in options) {\n      if (options.square in SQUARES) {\n        first_sq = last_sq = SQUARES[options.square];\n        single_square = true;\n      } else {\n        /* invalid square */\n        return [];\n      }\n    }\n \n    // Allow to add `defending moves` to compute the defencse of squares and pieces\n    var defending_allowed = (typeof options !== 'undefined' && 'defending_allowed' in options) ?\n        options.defending_allowed : false;\n\n\n    for (var i = first_sq; i <= last_sq; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) { i += 7; continue; }\n \n      var piece = board[i];\n      if (piece == null || piece.color !== us) {\n        continue;\n      }\n \n      if (piece.type === PAWN) {\n        /* single square, non-capturing */\n        var square = i + PAWN_OFFSETS[us][0];\n        if (board[square] == null) {\n            add_move(board, moves, i, square, BITS.NORMAL);\n \n          /* double square */\n          var square = i + PAWN_OFFSETS[us][1];\n          if (second_rank[us] === rank(i) && board[square] == null) {\n            add_move(board, moves, i, square, BITS.BIG_PAWN);\n          }\n        }\n \n        /* pawn captures */\n        for (j = 2; j < 4; j++) {\n          var square = i + PAWN_OFFSETS[us][j];\n          if (square & 0x88) continue;\n \n          if (board[square] != null &&\n              board[square].color === them) {\n              add_move(board, moves, i, square, BITS.CAPTURE);\n          } else if (square === ep_square) {\n              add_move(board, moves, i, ep_square, BITS.EP_CAPTURE);\n          // } else if (board[square] != null && board[square].color === us && defending_allowed) {\n          } else if (defending_allowed) {\n            console.log(SQUARES[square]);\n            add_move(board, moves, i, square, BITS.CAPTURE);\n          }\n        }\n      } else {\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n          var offset = PIECE_OFFSETS[piece.type][j];\n          var square = i;\n \n          while (true) {\n            square += offset;\n            if (square & 0x88) break;\n \n            if (board[square] == null) {\n              add_move(board, moves, i, square, BITS.NORMAL);\n            } else {\n              // if (board[square].color === us) break;\n              if (board[square].color === us) {\n                if (defending_allowed) {\n                  add_move(board, moves, i, square, BITS.CAPTURE);\n                }\n                break;\n              }\n              add_move(board, moves, i, square, BITS.CAPTURE);\n              break;\n            }\n \n            /* break, if knight or king */\n            if (piece.type === 'n' || piece.type === 'k') break;\n          }\n        }\n      } // other than pawn\n    }\n \n    /* check for castling if: a) we're generating all moves, or b) we're doing\n     * single square move generation on the king's square\n     */\n    if ((!single_square) || last_sq === kings[us]) {\n      /* king-side castling */\n      if (castling[us] & BITS.KSIDE_CASTLE) {\n        var castling_from = kings[us];\n        var castling_to = castling_from + 2;\n \n        if (board[castling_from + 1] == null &&\n            board[castling_to]       == null &&\n            !attacked(them, kings[us]) &&\n            !attacked(them, castling_from + 1) &&\n            !attacked(them, castling_to)) {\n          add_move(board, moves, kings[us] , castling_to,\n                   BITS.KSIDE_CASTLE);\n        }\n      }\n \n      /* queen-side castling */\n      if (castling[us] & BITS.QSIDE_CASTLE) {\n        var castling_from = kings[us];\n        var castling_to = castling_from - 2;\n \n        if (board[castling_from - 1] == null &&\n            board[castling_from - 2] == null &&\n            board[castling_from - 3] == null &&\n            !attacked(them, kings[us]) &&\n            !attacked(them, castling_from - 1) &&\n            !attacked(them, castling_to)) {\n          add_move(board, moves, kings[us], castling_to,\n                   BITS.QSIDE_CASTLE);\n        }\n      }\n    }\n \n    /* return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal) {\n      return moves;\n    }\n \n    /* filter out illegal moves */\n    var legal_moves = [];\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]);                                          // make_move also used to find legal move\n      if (!king_attacked(us)) {\n        legal_moves.push(moves[i]);\n      }\n      undo_move();\n    }\n \n    return legal_moves;  // legal move generation is also costly\n  } // generate_moves()\n\n\n  function swap_color_in_fen(remove_ep_field=false) {\n    // Ensure that the other color is active now\n    var tokens = generate_fen().split(/\\s+/);\n    tokens[1] = swap_color(tokens[1]);\n    if(remove_ep_field) tokens[3]='-';\n    var new_fen = tokens.join(' ');\n    var r = load(new_fen);\n    // console.log(r);\n  }\n\n\n  /*\n   * Returns a map with keys as all pieces (of the current color) and\n   * an array with defending pieces as value. If a piece is not defended,\n   * the array is empty\n   */\n  function defended_pieces(color_code = null, attack_square = false, remove_ep_field = false) {\n    var result = {};\n    // Fill the result with possibly defended pieces\n    var relevant_color;\n    if (color_code) {\n      relevant_color = color_code;\n    } else {\n      relevant_color = swap_color(turn);\n    }\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if ( attack_square || (board[i]) && (board[i].color === relevant_color)   ) {\n        var defended = board[i] ? board[i].type : '';\n        var defended_field = algebraic(i);\n        result[defended + defended_field] = [];\n      }\n      if ((i + 1) & 0x88) {\n        i += 8;\n      }\n    }\n    if (relevant_color !== turn) {\n      swap_color_in_fen(remove_ep_field);\n    }\n    // Check now all moves (even illegal ones that defend a piece)\n    var moves = generate_moves({ defending_allowed: true, legal: false });\n    for (var index = 0; index < moves.length; index++) {\n      var move = moves[index];\n      var defended;\n      if (attack_square) {\n        defended = move.captured ? move.captured : '';\n      } else {\n        defended = move.captured;\n      }\n      if (move.flags & BITS.EP_CAPTURE) continue;\n      var field_to = algebraic(move.to);\n      //console.log('Field to: ' + field_to);\n      if (attack_square || (defended && (get(field_to).color == relevant_color)) ) {\n        var defender = move.piece;\n        var field_from = algebraic(move.from);\n        var val = defender + field_from;\n        var key = defended + field_to;\n        result[key].push(val); \n      }\n    }\n    return result;\n\n  }\n\n  /*\n   * Returns a map with keys as all pieces (of the current color) and\n   * an array with attacking pieces as value. If a piece is not attacked,\n   * the array is empty.\n   */\n  function attacked_pieces(color_code = null, attack_square = false) {\n    var result = {};\n    // Fill the result with possibly attacked pieces\n    var relevant_color;\n    if (color_code) {\n      relevant_color = color_code;\n    } else {\n      relevant_color = swap_color(turn);\n    }\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if ( attack_square || (board[i]) && (board[i].color === relevant_color)  ) {\n        var attacked = board[i] ? board[i].type : '';\n        var attacked_field = algebraic(i);\n        result[attacked + attacked_field] = [];\n      }\n      if ((i + 1) & 0x88) {\n        i += 8;\n      }\n    }\n    if (relevant_color === turn) {\n      swap_color_in_fen();\n    }\n    // Check now for each possible move, if something is attacked\n    var moves = generate_moves();\n    for (var index = 0; index < moves.length; index++) {\n      var move = moves[index];\n      var attacked;\n      if (attack_square) {\n        attacked = move.captured ? move.captured : '';\n      } else {\n        attacked = move.captured;\n      }\n      if (attack_square || attacked) {\n        var attacker = move.piece;\n        var field_from = algebraic(move.from);\n        var val = attacker + field_from;\n        var field_to = algebraic(move.to);\n        var key = attacked + field_to;\n        if(result[key]) result[key].push(val); \n      }\n    }\n    return result;\n  }\n\n \n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n   * disambiguation bugs in Fritz and Chessbase.  See below:\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n  function move_to_san(move, sloppy) {\n \n    var output = '';\n \n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      var disambiguator = get_disambiguator(move, sloppy);\n \n      if (move.piece !== PAWN) {\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n \n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0];\n        }\n        output += 'x';\n      }\n \n      output += algebraic(move.to);\n \n      if (move.flags & BITS.PROMOTION) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n \n    make_move(move);\n    if (in_check()) {\n      if (in_checkmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n    undo_move();\n \n    return output;\n  }\n \n  // parses all of the decorators out of a SAN string\n  function stripped_san(move) {\n    return move.replace(/=/,'').replace(/[+#]?[?!]*$/,'');\n  }\n \n  function attacked(color, square) {\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) { i += 7; continue; }\n \n      /* if empty square or wrong color */\n      if (board[i] == null || board[i].color !== color) continue;\n \n      var piece = board[i];\n      var difference = i - square;\n      var index = difference + 119;\n \n      if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true;\n          } else {\n            if (piece.color === BLACK) return true;\n          }\n          continue;\n        }\n \n        /* if the piece is a knight or a king */\n        if (piece.type === 'n' || piece.type === 'k') return true;\n \n        var offset = RAYS[index];\n        var j = i + offset;\n \n        var blocked = false;\n        while (j !== square) {\n          if (board[j] != null) { blocked = true; break; }\n          j += offset;\n        }\n \n        if (!blocked) return true;\n      }\n    }\n \n    return false;\n  }\n \n  function king_attacked(color) {\n    return attacked(swap_color(color), kings[color]);\n  }\n \n  function in_check() {\n    return king_attacked(turn);\n  }\n \n  function in_checkmate() {\n    return in_check() && generate_moves().length === 0;\n  }\n \n  function in_stalemate() {\n    return !in_check() && generate_moves().length === 0;\n  }\n \n  function insufficient_material() {\n    var pieces = {};\n    var bishops = [];\n    var num_pieces = 0;\n    var sq_color = 0;\n \n    for (var i = SQUARES.a8; i<= SQUARES.h1; i++) {\n      sq_color = (sq_color + 1) % 2;\n      if (i & 0x88) { i += 7; continue; }\n \n      var piece = board[i];\n      if (piece) {\n        pieces[piece.type] = (piece.type in pieces) ?\n                              pieces[piece.type] + 1 : 1;\n        if (piece.type === BISHOP) {\n          bishops.push(sq_color);\n        }\n        num_pieces++;\n      }\n    }\n \n    /* k vs. k */\n    if (num_pieces === 2) { return true; }\n \n    /* k vs. kn .... or .... k vs. kb */\n    else if (num_pieces === 3 && (pieces[BISHOP] === 1 ||\n                                 pieces[KNIGHT] === 1)) { return true; }\n \n    /* kb vs. kb where any number of bishops are all on the same color */\n    else if (num_pieces === pieces[BISHOP] + 2) {\n      var sum = 0;\n      var len = bishops.length;\n      for (var i = 0; i < len; i++) {\n        sum += bishops[i];\n      }\n      if (sum === 0 || sum === len) { return true; }\n    }\n \n    return false;\n  }\n \n  function in_threefold_repetition() {\n    /* TODO: while this function is fine for casual use, a better\n     * implementation would use a Zobrist key (instead of FEN). the\n     * Zobrist key would be maintained in the make_move/undo_move functions,\n     * avoiding the costly that we do below.\n     */\n    var moves = [];\n    var positions = {};\n    var repetition = false;\n \n    while (true) {\n      var move = undo_move();\n      if (!move) break;\n      moves.push(move);\n    }\n \n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\n       * when checking for draw by rep */\n      var fen = generate_fen().split(' ').slice(0,4).join(' ');\n \n      /* has the position occurred three or move times */\n      positions[fen] = (fen in positions) ? positions[fen] + 1 : 1;\n      if (positions[fen] >= 3) {\n        repetition = true;\n      }\n \n      if (!moves.length) {\n        break;\n      }\n      make_move(moves.pop());\n    }\n \n    return repetition;\n  }\n \n  function push(move) {\n \n    history.push({\n      move: move,\n      kings: {b: kings.b, w: kings.w},\n      turn: turn,\n      castling: {b: castling.b, w: castling.w},\n      ep_square: ep_square,\n      half_moves: half_moves,\n      move_number: move_number\n    });\n  }\n \n  function make_move(move) {\n    var us = turn;\n    var them = swap_color(us);\n    push(move);\n \n    board[move.to] = board[move.from];\n    board[move.from] = null;\n \n    /* if ep capture, remove the captured pawn */\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (turn === BLACK) {\n        board[move.to - 16] = null;\n      } else {\n        board[move.to + 16] = null;\n      }\n    }\n \n    /* if pawn promotion, replace with new piece */\n    if (move.flags & BITS.PROMOTION) {\n      board[move.to] = {type: move.promotion, color: us};\n    }\n \n    /* if we moved the king */\n    if (board[move.to].type === KING) {\n      kings[board[move.to].color] = move.to;\n \n      /* if we castled, move the rook next to the king */\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        var castling_to = move.to - 1;\n        var castling_from = move.to + 1;\n        board[castling_to] = board[castling_from];\n        board[castling_from] = null;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        var castling_to = move.to + 1;\n        var castling_from = move.to - 2;\n        board[castling_to] = board[castling_from];\n        board[castling_from] = null;\n      }\n \n      /* turn off castling */\n      castling[us] = '';\n    }\n \n    /* turn off castling if we move a rook */\n    if (castling[us]) {\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square &&\n            castling[us] & ROOKS[us][i].flag) {\n          castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    }\n \n    /* turn off castling if we capture a rook */\n    if (castling[them]) {\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square &&\n            castling[them] & ROOKS[them][i].flag) {\n          castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    }\n \n    /* if big pawn move, update the en passant square */\n    if (move.flags & BITS.BIG_PAWN) {\n      if (turn === 'b') {\n        ep_square = move.to - 16;\n      } else {\n        ep_square = move.to + 16;\n      }\n    } else {\n      ep_square = EMPTY;\n    }\n \n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n    if (move.piece === PAWN) {\n      half_moves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      half_moves = 0;\n    } else {\n      half_moves++;\n    }\n \n    if (turn === BLACK) {\n      move_number++;\n    }\n    turn = swap_color(turn);\n  }\n \n  function undo_move() {\n \n    var old = history.pop();\n    if (old == null) { return null; }\n \n    var move = old.move;\n    kings = old.kings;\n    turn = old.turn;\n    castling = old.castling;\n    ep_square = old.ep_square;\n    half_moves = old.half_moves;\n    move_number = old.move_number;\n \n    var us = turn;\n    var them = swap_color(turn);\n \n    board[move.from] = board[move.to];\n    board[move.from].type = move.piece;  // to undo any promotions\n    board[move.to] = null;\n \n    if (move.flags & BITS.CAPTURE) {\n      board[move.to] = {type: move.captured, color: them};\n    } else if (move.flags & BITS.EP_CAPTURE) {\n      var index;\n      if (us === BLACK) {\n        index = move.to - 16;\n      } else {\n        index = move.to + 16;\n      }\n      board[index] = {type: PAWN, color: them};\n    }\n \n \n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      var castling_to, castling_from;\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castling_to = move.to + 1;\n        castling_from = move.to - 1;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        castling_to = move.to - 2;\n        castling_from = move.to + 1;\n      }\n \n      board[castling_to] = board[castling_from];\n      board[castling_from] = null;\n    }\n \n    return move;\n  }\n \n  /* this function is used to uniquely identify ambiguous moves */\n  function get_disambiguator(move, sloppy) {\n    var moves = generate_moves({legal: !sloppy});\n \n    var from = move.from;\n    var to = move.to;\n    var piece = move.piece;\n \n    var ambiguities = 0;\n    var same_rank = 0;\n    var same_file = 0;\n \n    for (var i = 0, len = moves.length; i < len; i++) {\n      var ambig_from = moves[i].from;\n      var ambig_to = moves[i].to;\n      var ambig_piece = moves[i].piece;\n \n      /* if a move of the same piece type ends on the same to square, we'll\n       * need to add a disambiguator to the algebraic notation\n       */\n      if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n        ambiguities++;\n \n        if (rank(from) === rank(ambig_from)) {\n          same_rank++;\n        }\n \n        if (file(from) === file(ambig_from)) {\n          same_file++;\n        }\n      }\n    }\n \n    if (ambiguities > 0) {\n      /* if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      if (same_rank > 0 && same_file > 0) {\n        return algebraic(from);\n      }\n      /* if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      else if (same_file > 0) {\n        return algebraic(from).charAt(1);\n      }\n      /* else use the file symbol */\n      else {\n        return algebraic(from).charAt(0);\n      }\n    }\n \n    return '';\n  }\n \n  function ascii() {\n    var s = '   +------------------------+\\n';\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* display the rank */\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |';\n      }\n \n      /* empty piece */\n      if (board[i] == null) {\n        s += ' . ';\n      } else {\n        var piece = board[i].type;\n        var color = board[i].color;\n        var symbol = (color === WHITE) ?\n                     piece.toUpperCase() : piece.toLowerCase();\n        s += ' ' + symbol + ' ';\n      }\n \n      if ((i + 1) & 0x88) {\n        s += '|\\n';\n        i += 8;\n      }\n    }\n    s += '   +------------------------+\\n';\n    s += '     a  b  c  d  e  f  g  h\\n';\n \n    return s;\n  }\n \n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  function move_from_san(move, sloppy) {\n    // strip off any move decorations: e.g Nf3+?!\n    var clean_move = stripped_san(move);\n    // if we're using the sloppy parser run a regex to grab piece, to, and from\n    // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\n    if (sloppy) {\n      var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n      if (matches) {\n        var piece = matches[1];\n        var from = matches[2];\n        var to = matches[3];\n        var promotion = matches[4];\n      }\n    }\n \n    var moves = generate_moves();\n    for (var i = 0, len = moves.length; i < len; i++) {\n      // try the strict parser first, then the sloppy parser if requested\n      // by the user\n      if ((clean_move === stripped_san(move_to_san(moves[i]))) ||\n          (sloppy && clean_move === stripped_san(move_to_san(moves[i], true)))) {\n  \n        fen_history.push(generate_fen());  //fen_history\n \n        return moves[i];\n      } else {\n        if (matches &&\n            (!piece || piece.toLowerCase() == moves[i].piece) &&\n            SQUARES[from] == moves[i].from &&\n            SQUARES[to] == moves[i].to &&\n            (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n          return moves[i];\n        }\n      }\n    }\n    return null;\n  }  // move_from_san\n \n \n  /*****************************************************************************\n   * UTILITY FUNCTIONS\n   ****************************************************************************/\n  function rank(i) {\n    return i >> 4;\n  }\n \n  function file(i) {\n    return i & 15;\n  }\n \n  function algebraic(i){\n    var f = file(i), r = rank(i);\n    return 'abcdefgh'.substring(f,f+1) + '87654321'.substring(r,r+1);\n  }\n \n  function swap_color(c) {\n    return c === WHITE ? BLACK : WHITE;\n  }\n \n  function is_digit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n  }\n \n  /* pretty = external move object */\n  function make_pretty(ugly_move) {\n    var move = clone(ugly_move);\n    move.san = move_to_san(move, false);\n    move.to = algebraic(move.to);\n    move.from = algebraic(move.from);\n \n    var flags = '';\n \n    for (var flag in BITS) {\n      if (BITS[flag] & move.flags) {\n        flags += FLAGS[flag];\n      }\n    }\n    move.flags = flags;\n \n    return move;\n  }\n \n  function clone(obj) {\n    var dupe = (obj instanceof Array) ? [] : {};\n \n    for (var property in obj) {\n      if (typeof property === 'object') {\n        dupe[property] = clone(obj[property]);\n      } else {\n        dupe[property] = obj[property];\n      }\n    }\n \n    return dupe;\n  }\n \n  function trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n  }\n \n  /*****************************************************************************\n   * DEBUGGING UTILITIES\n   ****************************************************************************/\n  function perft(depth) {\n    var moves = generate_moves({legal: false});\n    var nodes = 0;\n    var color = turn;\n \n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]);\n      if (!king_attacked(color)) {\n        if (depth - 1 > 0) {\n          var child_nodes = perft(depth - 1);\n          nodes += child_nodes;\n        } else {\n          nodes++;\n        }\n      }\n      undo_move();\n    }\n \n    return nodes;\n  }\n \n  return {\n    /***************************************************************************\n     * PUBLIC CONSTANTS (is there a better way to do this?)\n     **************************************************************************/\n    WHITE: WHITE,\n    BLACK: BLACK,\n    PAWN: PAWN,\n    KNIGHT: KNIGHT,\n    BISHOP: BISHOP,\n    ROOK: ROOK,\n    QUEEN: QUEEN,\n    KING: KING,\n    SQUARES: (function() {\n                /* from the ECMA-262 spec (section 12.6.4):\n                 * \"The mechanics of enumerating the properties ... is\n                 * implementation dependent\"\n                 * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n                 * ordered correctly\n                 */\n                var keys = [];\n                for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n                  if (i & 0x88) { i += 7; continue; }\n                  keys.push(algebraic(i));\n                }\n                return keys;\n              })(),\n    FLAGS: FLAGS,\n \n    /***************************************************************************\n     * PUBLIC API\n     **************************************************************************/\n    load: function(fen) {\n      return load(fen);\n    },\n \n    reset: function() {\n      return reset();\n    },\n \n    moves: function(options) {\n      /* The internal representation of a chess move is in 0x88 format, and\n       * not meant to be human-readable.  The code below converts the 0x88\n       * square coordinates to algebraic coordinates.  It also prunes an\n       * unnecessary move keys resulting from a verbose call.\n       */\n \n      var ugly_moves = generate_moves(options);\n      var moves = [];\n \n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\n \n        /* does the user want a full move object (most likely not), or just\n         * SAN\n         */\n        if (typeof options !== 'undefined' && 'verbose' in options &&\n            options.verbose) {\n          moves.push(make_pretty(ugly_moves[i]));\n        } else {\n          moves.push(move_to_san(ugly_moves[i], false));\n        }\n      }\n \n      return moves;\n    },\n\n    defended_pieces: function(color_code, attack_square, remove_ep_field) {\n      return defended_pieces(color_code, attack_square, remove_ep_field);\n    },\n\n    attacked_pieces: function(color_code, attack_square) {\n      return attacked_pieces(color_code, attack_square);\n    },\n \n    in_check: function() {\n      return in_check();\n    },\n \n    in_checkmate: function() {\n      return in_checkmate();\n    },\n \n    in_stalemate: function() {\n      return in_stalemate();\n    },\n \n    in_draw: function() {\n      return half_moves >= 100 ||\n             in_stalemate() ||\n             insufficient_material() ||\n             in_threefold_repetition();\n    },\n \n    insufficient_material: function() {\n      return insufficient_material();\n    },\n \n    in_threefold_repetition: function() {\n      return in_threefold_repetition();\n    },\n \n    game_over: function() {\n      return half_moves >= 100 ||\n             in_checkmate() ||\n             in_stalemate() ||\n             insufficient_material() ||\n             in_threefold_repetition();\n    },\n \n    validate_fen: function(fen) {\n      return validate_fen(fen);\n    },\n \n    fen: function() {\n      return generate_fen();\n    },\n \n    board: function() {\n      var output = [],\n          row    = [];\n \n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (board[i] == null) {\n          row.push(null)\n        } else {\n          row.push({type: board[i].type, color: board[i].color})\n        }\n        if ((i + 1) & 0x88) {\n          output.push(row);\n          row = []\n          i += 8;\n        }\n      }\n \n      return output;\n    },\n \n    pawns: function(){\n      return pawns.map((e, i) =>{});\n    },\n\n    pgn: function(options) {\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var newline = (typeof options === 'object' &&\n                     typeof options.newline_char === 'string') ?\n                     options.newline_char : '\\n';\n      var max_width = (typeof options === 'object' &&\n                       typeof options.max_width === 'number') ?\n                       options.max_width : 0;\n      var result = [];\n      var header_exists = false;\n \n      /* add the PGN header headerrmation */\n      for (var i in header) {\n        /* TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \\\"' + header[i] + '\\\"]' + newline);\n        header_exists = true;\n      }\n \n      if (header_exists && history.length) {\n        result.push(newline);\n      }\n \n      /* pop all of history onto reversed_history */\n      var reversed_history = [];\n      while (history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n \n      var moves = [];\n      var move_string = '';\n \n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop();\n \n        /* if the position started with black to move, start PGN with 1. ... */\n        if (!history.length && move.color === 'b') {\n          move_string = move_number + '. ...';\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (move_string.length) {\n            moves.push(move_string);\n          }\n          move_string = move_number + '.';\n        }\n \n        move_string = move_string + ' ' + move_to_san(move, false);\n        make_move(move);\n      }\n \n      /* are there any other leftover moves? */\n      if (move_string.length) {\n        moves.push(move_string);\n      }\n \n      /* is there a result? */\n      if (typeof header.Result !== 'undefined') {\n        moves.push(header.Result);\n      }\n \n      /* history should be back to what is was before we started generating PGN,\n       * so join together moves\n       */\n      if (max_width === 0) {\n        return result.join('') + moves.join(' ');\n      }\n \n      /* wrap the PGN output at max_width */\n      var current_width = 0;\n      for (var i = 0; i < moves.length; i++) {\n        /* if the current move will push past max_width */\n        if (current_width + moves[i].length > max_width && i !== 0) {\n \n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop();\n          }\n \n          result.push(newline);\n          current_width = 0;\n        } else if (i !== 0) {\n          result.push(' ');\n          current_width++;\n        }\n        result.push(moves[i]);\n        current_width += moves[i].length;\n      }\n \n      return result.join('');\n    },  //pgn()\n \n    load_pgn: function(pgn, options) {\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?\n                    options.sloppy : false;\n \n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\');\n      }\n \n      function has_keys(object) {\n        for (var key in object) {\n          return true;\n        }\n        return false;\n      }\n \n      function parse_pgn_header(header, options) {\n \n        var newline_char = (typeof options === 'object' &&\n                            typeof options.newline_char === 'string') ?\n                            options.newline_char : '\\r?\\n';\n        var header_obj = {};\n        var headers = header.split(new RegExp(mask(newline_char)));\n        var key = '';\n        var value = '';\n \n        for (var i = 0; i < headers.length; i++) {\n          key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1');\n          value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\]$/, '$1');\n          if (trim(key).length > 0) {\n            header_obj[key] = value;\n          }\n        }\n \n        return header_obj;\n      }  // parse_pgn_header\n \n      var newline_char = (typeof options === 'object' &&\n                          typeof options.newline_char === 'string') ?\n                          options.newline_char : '\\r?\\n';\n \n      // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n      var header_regex = new RegExp('^(\\\\[((?:' + mask(newline_char) + ')|.)*\\\\])' +\n                              '(?:' + mask(newline_char) + '){2}');\n \n      // If no header given, begin with moves.\n      var header_string = header_regex.test(pgn) ? header_regex.exec(pgn)[1] : '';\n \n      // Put the board in the starting position\n      reset();\n \n      /* parse PGN header */\n      var headers = parse_pgn_header(header_string, options);\n      for (var key in headers) {\n        set_header([key, headers[key]]);\n      }\n \n      /* load the starting position indicated by [Setup '1'] and\n      * [FEN position] */\n      if (headers['SetUp'] === '1') {\n          if (!(('FEN' in headers) && load(headers['FEN'], true ))) { // second argument to load: don't clear the headers\n            return false;\n          }\n      }\n \n      /* delete header to get the moves */\n      var ms = pgn.replace(header_string, '').replace(new RegExp(mask(newline_char), 'g'), ' ');\n \n      /* delete comments */\n      ms = ms.replace(/(\\{[^}]+\\})+?/g, '');\n \n      /* delete recursive annotation variations */\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g;\n      while (rav_regex.test(ms)) {\n        ms = ms.replace(rav_regex, '');\n      }\n \n      /* delete move numbers */\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n \n      /* delete ... indicating black to move */\n      ms = ms.replace(/\\.\\.\\./g, '');\n \n      /* delete numeric annotation glyphs */\n      ms = ms.replace(/\\$\\d+/g, '');\n \n      /* trim and get array of moves */\n      var moves = trim(ms).split(new RegExp(/\\s+/));\n \n      /* delete empty entries */\n      moves = moves.join(',').replace(/,,+/g, ',').split(',');\n      var move = '';\n \n      for (var half_move = 0; half_move < moves.length - 1; half_move++) {\n        move = move_from_san(moves[half_move], sloppy);\n \n        /* move not possible! (don't clear the board to examine to show the\n         * latest valid position)\n         */\n        if (move == null) {\n          return false;\n        } else {\n          make_move(move);\n        }\n      }\n \n      /* examine last move */\n      move = moves[moves.length - 1];\n      if (POSSIBLE_RESULTS.indexOf(move) > -1) {\n        if (has_keys(header) && typeof header.Result === 'undefined') {\n          set_header(['Result', move]);\n        }\n      }\n      else {\n        move = move_from_san(move, sloppy);\n        if (move == null) {\n          return false;\n        } else {\n          make_move(move);\n        }\n      }\n      return true;\n    }, // load_pgn()\n \n    header: function() {\n      return set_header(arguments);\n    },\n \n    ascii: function() {\n      return ascii();\n    },\n \n    turn: function() {\n      return turn;\n    },\n \n    move: function(move, options) {\n      /* The move function can be called with in the following parameters:\n       *\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n       *\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\n       *         to :'h8',      fields are ignored)\n       *         promotion: 'q',\n       *      })\n       */\n \n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?\n                    options.sloppy : false;\n \n      var move_obj = null;\n \n      if (typeof move === 'string') {\n        move_obj = move_from_san(move, sloppy);\n      } else if (typeof move === 'object') {\n        var moves = generate_moves();\n \n        /* convert the pretty move object to an ugly move object */\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (move.from === algebraic(moves[i].from) &&\n              move.to === algebraic(moves[i].to) &&\n              (!('promotion' in moves[i]) ||\n              move.promotion === moves[i].promotion)) {\n            move_obj = moves[i];\n            break;\n          }\n        }\n      }\n \n      /* failed to find move */\n      if (!move_obj) {\n        return null;\n      }\n \n      /* need to make a copy of move because we can't generate SAN after the\n       * move is made\n       */\n      var pretty_move = make_pretty(move_obj);\n \n      make_move(move_obj);\n \n      return pretty_move;\n    },\n \n    undo: function() {\n      var move = undo_move();\n      return (move) ? make_pretty(move) : null;\n    },\n \n    clear: function() {\n      return clear();\n    },\n \n    put: function(piece, square) {\n      return put(piece, square);\n    },\n \n    get: function(square) {\n      return get(square);\n    },\n \n    remove: function(square) {\n      return remove(square);\n    },\n \n    perft: function(depth) {\n      return perft(depth);\n    },\n \n    square_color: function(square) {\n      if (square in SQUARES) {\n        var sq_0x88 = SQUARES[square];\n        return ((rank(sq_0x88) + file(sq_0x88)) % 2 === 0) ? 'light' : 'dark';\n      }\n \n      return null;\n    },\n \n    history: function(options) {\n      var reversed_history = [];\n      var move_history = [];\n      var verbose = (typeof options !== 'undefined' && 'verbose' in options &&\n                     options.verbose);\n \n      while (history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n \n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop();\n        if (verbose) {\n          move_history.push(make_pretty(move));\n        } else {\n          move_history.push(move_to_san(move));\n        }\n        make_move(move);\n      }\n \n      return move_history;\n    }, // history()\n \n    nextmv: function () {\n      if(fen_history.length > 0 ){\n          if(fh_curr > fen_history.length -2 ){\n             load(fen_history[0])\n          }else{\n            load(fen_history[fh_curr]);\n            fh_curr++;\n          }\n      }\n    },\n \n    prevmv: function () {\n      if(fen_history.length > 0 ){\n          if(fh_curr < 1  ){\n             load(fen_history[fen_history.length -1])\n          }else{\n            load(fen_history[fh_curr]);\n            fh_curr--;\n          }\n      }\n    }\n \n  };  //closure object\n};\n \n/* export Chess object if using node or any other CommonJS compatible\n * environment */\nif (typeof exports !== 'undefined') exports.Chess = Chess;\n/* export Chess object for any RequireJS compatible environment */\nif (typeof define !== 'undefined') define( function () { return Chess;  });"]},"metadata":{},"sourceType":"script"}