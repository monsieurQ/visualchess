{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = exports.BoardValidation = void 0;\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/createClass\"));\n\nvar _piece = require(\"./piece\");\n\nvar _board = require(\"./board\");\n\nvar _pieceValidation = require(\"./pieceValidation\");\n/**\n\tBoardValidation determines viable move options for all pieces\n\tgiven the current state of the board. If it's the White sides turn\n\tto attack, only White piece move options are evaluated (and visa versa).\n\n\tBoardValidation is intended to be the 2nd phase of move\n\tvalidation that is capable of taking into account factors across pieces\n\ton the board (and not just the pieces themselves). For example, King\n\tcastle eligibility is determined based on whether or not both the candidate\n\tKing and Rook pieces have not moved and whether or not the path of travel\n\tfor the King would result in the King being placed in check at any\n\tpoint during the travel. Individual Piece validation wouldn't be sufficient\n\tto determine whether or not this move is possible.\n\n\tAdditionally, isSquareAttacked exists on the BoardValidation object. While\n\tthis method could have easily existed within the PieceValidation object\n\tI've kept it in BoardValidation so that PieceValidation remains truly\n\tagnostic of the other pieces on the same board.\n\n\tDue to how BoardValidation actually functions, the client only needs to\n\tinstantiate a BoardValidation for the Game and call the start method\n\tin order to evaluate every Piece's valid move options. There is no need\n\tto call PieceValidation (and doing so wouldn't give an accurate picture\n\tof what is possible anyway).\n*/\n\n\nvar BoardValidation = /*#__PURE__*/function () {\n  function BoardValidation(game) {\n    (0, _classCallCheck2[\"default\"])(this, BoardValidation);\n    this.board = game ? game.board : null;\n    this.game = game;\n  }\n\n  (0, _createClass2[\"default\"])(BoardValidation, [{\n    key: \"evaluateCastle\",\n    value: function evaluateCastle(validMoves) {\n      var getValidSquares = function getValidSquares(sq) {\n        var i = 0;\n\n        for (i = 0; i < validMoves.length; i++) {\n          if (validMoves[i].src === sq) {\n            return validMoves[i].squares;\n          }\n        }\n      },\n          interimMove = null,\n          // eslint-disable-next-line no-magic-numbers\n      rank = this.game.getCurrentSide() === _piece.SideType.White ? 1 : 8,\n          squares = {\n        'a': this.board.getSquare('a', rank),\n        'b': this.board.getSquare('b', rank),\n        'c': this.board.getSquare('c', rank),\n        'd': this.board.getSquare('d', rank),\n        'e': this.board.getSquare('e', rank),\n        'f': this.board.getSquare('f', rank),\n        'g': this.board.getSquare('g', rank),\n        'h': this.board.getSquare('h', rank)\n      }; // is king eligible\n\n\n      if (squares.e.piece && squares.e.piece.type === _piece.PieceType.King && squares.e.piece.moveCount === 0 && !this.isSquareAttacked(squares.e)) {\n        // is left rook eligible\n        if (squares.a.piece && squares.a.piece.type === _piece.PieceType.Rook && squares.a.piece.moveCount === 0) {\n          // are the squares between king and rook clear\n          if (!squares.b.piece && !squares.c.piece && !squares.d.piece) {\n            // when king moves through squares between, is it in check\n            interimMove = this.board.move(squares.e, squares.d, true);\n\n            if (!this.isSquareAttacked(squares.d)) {\n              interimMove.undo();\n              interimMove = this.board.move(squares.e, squares.c, true);\n\n              if (!this.isSquareAttacked(squares.c)) {\n                getValidSquares(squares.e).push(squares.c);\n              }\n            }\n\n            interimMove.undo();\n          }\n        } // is right rook eligible\n\n\n        if (squares.h.piece && squares.h.piece.type === _piece.PieceType.Rook && squares.h.piece.moveCount === 0) {\n          // are the squares between king and rook clear\n          if (!squares.g.piece && !squares.f.piece) {\n            // when king moves through squares between, is it in check\n            interimMove = this.board.move(squares.e, squares.f, true);\n\n            if (!this.isSquareAttacked(squares.f)) {\n              interimMove.undo();\n              interimMove = this.board.move(squares.e, squares.g, true);\n\n              if (!this.isSquareAttacked(squares.g)) {\n                getValidSquares(squares.e).push(squares.g);\n              }\n            }\n\n            interimMove.undo();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"filterKingAttack\",\n    value: function filterKingAttack(kingSquare, moves) {\n      var filteredMoves = [],\n          i = 0,\n          isCheck = false,\n          n = 0,\n          r = null,\n          squares = [];\n\n      for (i = 0; i < moves.length; i++) {\n        squares = [];\n\n        for (n = 0; n < moves[i].squares.length; n++) {\n          // simulate move on the board\n          r = this.board.move(moves[i].src, moves[i].squares[n], true); // check if king is attacked\n\n          if (moves[i].squares[n].piece.type !== _piece.PieceType.King) {\n            isCheck = this.isSquareAttacked(kingSquare);\n          } else {\n            isCheck = this.isSquareAttacked(moves[i].squares[n]);\n          } // reverse the move\n\n\n          r.undo();\n\n          if (!isCheck) {\n            squares.push(moves[i].squares[n]);\n          }\n        }\n\n        if (squares && squares.length > 0) {\n          filteredMoves.push({\n            squares: squares,\n            src: moves[i].src\n          });\n        }\n      }\n\n      return filteredMoves;\n    }\n  }, {\n    key: \"findAttackers\",\n    value: function findAttackers(sq) {\n      if (!sq || !sq.piece) {\n        return {\n          attacked: false,\n          blocked: false\n        };\n      }\n\n      var\n      /* eslint no-invalid-this: 0 */\n      isAttacked = function isAttacked(b, n) {\n        var context = {},\n            currentSquare = b.getNeighborSquare(sq, n);\n\n        while (currentSquare) {\n          context = {\n            attacked: currentSquare.piece && currentSquare.piece.side !== sq.piece.side,\n            blocked: currentSquare.piece && currentSquare.piece.side === sq.piece.side,\n            piece: currentSquare.piece,\n            square: currentSquare\n          };\n\n          if (context.attacked) {\n            // verify that the square is actually attacked\n            _pieceValidation.PieceValidation.create(context.piece.type, b).start(currentSquare, setAttacked(context));\n\n            currentSquare = null;\n          } else if (context.blocked) {\n            currentSquare = null;\n          } else {\n            currentSquare = b.getNeighborSquare(currentSquare, n);\n          }\n        }\n\n        return context;\n      },\n          isAttackedByKnight = function isAttackedByKnight(b, n) {\n        var context,\n            currentSquare = b.getNeighborSquare(sq, n);\n        context = {\n          attacked: false,\n          blocked: false,\n          piece: currentSquare ? currentSquare.piece : currentSquare,\n          square: currentSquare\n        };\n\n        if (currentSquare && currentSquare.piece && currentSquare.piece.type === _piece.PieceType.Knight) {\n          _pieceValidation.PieceValidation.create(_piece.PieceType.Knight, b).start(currentSquare, setAttacked(context));\n        }\n\n        return context;\n      },\n          self = this,\n          setAttacked = function setAttacked(c) {\n        return function (err, squares) {\n          if (!err) {\n            var i = 0;\n\n            for (i = 0; i < squares.length; i++) {\n              if (squares[i] === sq) {\n                c.attacked = true;\n                return;\n              }\n            }\n          }\n\n          c.attacked = false;\n        };\n      };\n\n      return [isAttacked(self.board, _board.NeighborType.Above), isAttacked(self.board, _board.NeighborType.AboveRight), isAttacked(self.board, _board.NeighborType.Right), isAttacked(self.board, _board.NeighborType.BelowRight), isAttacked(self.board, _board.NeighborType.Below), isAttacked(self.board, _board.NeighborType.BelowLeft), isAttacked(self.board, _board.NeighborType.Left), isAttacked(self.board, _board.NeighborType.AboveLeft), // fix for issue #4\n      isAttackedByKnight(self.board, _board.NeighborType.KnightAboveRight), isAttackedByKnight(self.board, _board.NeighborType.KnightRightAbove), isAttackedByKnight(self.board, _board.NeighborType.KnightBelowRight), isAttackedByKnight(self.board, _board.NeighborType.KnightRightBelow), isAttackedByKnight(self.board, _board.NeighborType.KnightBelowLeft), isAttackedByKnight(self.board, _board.NeighborType.KnightLeftBelow), isAttackedByKnight(self.board, _board.NeighborType.KnightAboveLeft), isAttackedByKnight(self.board, _board.NeighborType.KnightLeftAbove)].filter(function (result) {\n        return result.attacked;\n      });\n    }\n  }, {\n    key: \"isSquareAttacked\",\n    value: function isSquareAttacked(sq) {\n      return this.findAttackers(sq).length !== 0;\n    }\n  }, {\n    key: \"start\",\n    value: function start(callback) {\n      var _this = this; // ensure callback is set\n\n\n      callback = callback || function (err, validMoves) {\n        return new _promise[\"default\"](function (resolve, reject) {\n          if (err) {\n            return reject(err);\n          }\n\n          return resolve(validMoves);\n        });\n      };\n\n      var i = 0,\n          kingSquare = null,\n          setValidMoves = function setValidMoves(v, sq) {\n        return function (err, squares) {\n          if (err) {\n            return callback(err);\n          }\n\n          if (squares && squares.length > 0) {\n            v.push({\n              squares: squares,\n              src: sq\n            });\n          }\n        };\n      },\n          squares = [],\n          validMoves = [];\n\n      if (this.board) {\n        // get squares with pieces for which to evaluate move options\n        squares = this.board.getSquares(this.game.getCurrentSide());\n\n        for (i = 0; i < squares.length; i++) {\n          // set king to refer to later\n          if (squares[i].piece.type === _piece.PieceType.King) {\n            kingSquare = squares[i];\n          }\n\n          if (squares[i] && squares[i].piece) {\n            _pieceValidation.PieceValidation.create(squares[i].piece.type, this.board).start(squares[i], setValidMoves(validMoves, squares[i]));\n          }\n        } // perform king castle validation\n\n\n        this.evaluateCastle(validMoves); // make sure moves only contain escape & non-check options\n\n        validMoves = this.filterKingAttack(kingSquare, validMoves); // find any pieces attacking the king\n\n        this.findAttackers(kingSquare).forEach(function (attacker) {\n          if (!validMoves.length) {\n            _this.game.emit('checkmate', {\n              attackingSquare: attacker.square,\n              kingSquare: kingSquare\n            });\n\n            return;\n          }\n\n          _this.game.emit('check', {\n            attackingSquare: attacker.square,\n            kingSquare: kingSquare\n          });\n        });\n      } else {\n        return callback(new Error('board is invalid'));\n      }\n\n      return callback(null, validMoves);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(game) {\n      return new BoardValidation(game);\n    }\n  }]);\n  return BoardValidation;\n}();\n\nexports.BoardValidation = BoardValidation;\nvar _default = {\n  BoardValidation: BoardValidation\n};\nexports[\"default\"] = _default;","map":{"version":3,"sources":["boardValidation.js"],"names":["BoardValidation","game","validMoves","getValidSquares","i","interimMove","rank","SideType","squares","PieceType","kingSquare","moves","filteredMoves","isCheck","n","r","src","sq","attacked","blocked","isAttacked","context","currentSquare","b","piece","square","PieceValidation","setAttacked","isAttackedByKnight","self","c","NeighborType","result","callback","reject","resolve","setValidMoves","v","attackingSquare","attacker"],"mappings":"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","sourcesContent":["/**\n\tBoardValidation determines viable move options for all pieces\n\tgiven the current state of the board. If it's the White sides turn\n\tto attack, only White piece move options are evaluated (and visa versa).\n\n\tBoardValidation is intended to be the 2nd phase of move\n\tvalidation that is capable of taking into account factors across pieces\n\ton the board (and not just the pieces themselves). For example, King\n\tcastle eligibility is determined based on whether or not both the candidate\n\tKing and Rook pieces have not moved and whether or not the path of travel\n\tfor the King would result in the King being placed in check at any\n\tpoint during the travel. Individual Piece validation wouldn't be sufficient\n\tto determine whether or not this move is possible.\n\n\tAdditionally, isSquareAttacked exists on the BoardValidation object. While\n\tthis method could have easily existed within the PieceValidation object\n\tI've kept it in BoardValidation so that PieceValidation remains truly\n\tagnostic of the other pieces on the same board.\n\n\tDue to how BoardValidation actually functions, the client only needs to\n\tinstantiate a BoardValidation for the Game and call the start method\n\tin order to evaluate every Piece's valid move options. There is no need\n\tto call PieceValidation (and doing so wouldn't give an accurate picture\n\tof what is possible anyway).\n*/\nimport { PieceType, SideType } from './piece';\nimport { NeighborType } from './board';\nimport { PieceValidation } from './pieceValidation';\n\nexport class BoardValidation {\n\tconstructor (game) {\n\t\tthis.board = game ? game.board : null;\n\t\tthis.game = game;\n\t}\n\n\tstatic create (game) {\n\t\treturn new BoardValidation(game);\n\t}\n\n\tevaluateCastle (validMoves) {\n\t\tlet\n\t\t\tgetValidSquares = (sq) => {\n\t\t\t\tlet i = 0;\n\n\t\t\t\tfor (i = 0; i < validMoves.length; i++) {\n\t\t\t\t\tif (validMoves[i].src === sq) {\n\t\t\t\t\t\treturn validMoves[i].squares;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tinterimMove = null,\n\t\t\t// eslint-disable-next-line no-magic-numbers\n\t\t\trank = this.game.getCurrentSide() === SideType.White ? 1 : 8,\n\t\t\tsquares = {\n\t\t\t\t'a' : this.board.getSquare('a', rank),\n\t\t\t\t'b' : this.board.getSquare('b', rank),\n\t\t\t\t'c' : this.board.getSquare('c', rank),\n\t\t\t\t'd' : this.board.getSquare('d', rank),\n\t\t\t\t'e' : this.board.getSquare('e', rank),\n\t\t\t\t'f' : this.board.getSquare('f', rank),\n\t\t\t\t'g' : this.board.getSquare('g', rank),\n\t\t\t\t'h' : this.board.getSquare('h', rank)\n\t\t\t};\n\n\t\t// is king eligible\n\t\tif (squares.e.piece &&\n\t\t\t\tsquares.e.piece.type === PieceType.King &&\n\t\t\t\tsquares.e.piece.moveCount === 0 &&\n\t\t\t\t!this.isSquareAttacked(squares.e)) {\n\n\t\t\t// is left rook eligible\n\t\t\tif (squares.a.piece &&\n\t\t\t\t\tsquares.a.piece.type === PieceType.Rook &&\n\t\t\t\t\tsquares.a.piece.moveCount === 0) {\n\n\t\t\t\t// are the squares between king and rook clear\n\t\t\t\tif (!squares.b.piece &&\n\t\t\t\t\t\t!squares.c.piece &&\n\t\t\t\t\t\t!squares.d.piece) {\n\n\t\t\t\t\t// when king moves through squares between, is it in check\n\t\t\t\t\tinterimMove = this.board.move(squares.e, squares.d, true);\n\t\t\t\t\tif (!this.isSquareAttacked(squares.d)) {\n\t\t\t\t\t\tinterimMove.undo();\n\t\t\t\t\t\tinterimMove = this.board.move(squares.e, squares.c, true);\n\n\t\t\t\t\t\tif (!this.isSquareAttacked(squares.c)) {\n\t\t\t\t\t\t\tgetValidSquares(squares.e).push(squares.c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tinterimMove.undo();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// is right rook eligible\n\t\t\tif (squares.h.piece &&\n\t\t\t\t\tsquares.h.piece.type === PieceType.Rook &&\n\t\t\t\t\tsquares.h.piece.moveCount === 0) {\n\n\t\t\t\t// are the squares between king and rook clear\n\t\t\t\tif (!squares.g.piece && !squares.f.piece) {\n\t\t\t\t\t// when king moves through squares between, is it in check\n\t\t\t\t\tinterimMove = this.board.move(squares.e, squares.f, true);\n\t\t\t\t\tif (!this.isSquareAttacked(squares.f)) {\n\t\t\t\t\t\tinterimMove.undo();\n\t\t\t\t\t\tinterimMove = this.board.move(squares.e, squares.g, true);\n\n\t\t\t\t\t\tif (!this.isSquareAttacked(squares.g)) {\n\t\t\t\t\t\t\tgetValidSquares(squares.e).push(squares.g);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tinterimMove.undo();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfilterKingAttack (kingSquare, moves) {\n\t\tlet\n\t\t\tfilteredMoves = [],\n\t\t\ti = 0,\n\t\t\tisCheck = false,\n\t\t\tn = 0,\n\t\t\tr = null,\n\t\t\tsquares = [];\n\n\t\tfor (i = 0; i < moves.length; i++) {\n\t\t\tsquares = [];\n\n\t\t\tfor (n = 0; n < moves[i].squares.length; n++) {\n\t\t\t\t// simulate move on the board\n\t\t\t\tr = this.board.move(moves[i].src, moves[i].squares[n], true);\n\n\t\t\t\t// check if king is attacked\n\t\t\t\tif (moves[i].squares[n].piece.type !== PieceType.King) {\n\t\t\t\t\tisCheck = this.isSquareAttacked(kingSquare);\n\t\t\t\t} else {\n\t\t\t\t\tisCheck = this.isSquareAttacked(moves[i].squares[n]);\n\t\t\t\t}\n\n\t\t\t\t// reverse the move\n\t\t\t\tr.undo();\n\n\t\t\t\tif (!isCheck) {\n\t\t\t\t\tsquares.push(moves[i].squares[n]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (squares && squares.length > 0) {\n\t\t\t\tfilteredMoves.push({\n\t\t\t\t\tsquares,\n\t\t\t\t\tsrc : moves[i].src\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn filteredMoves;\n\t}\n\n\tfindAttackers (sq) {\n\t\tif (!sq || !sq.piece) {\n\t\t\treturn {\n\t\t\t\tattacked : false,\n\t\t\t\tblocked : false\n\t\t\t};\n\t\t}\n\n\t\tlet\n\t\t\t/* eslint no-invalid-this: 0 */\n\t\t\tisAttacked = (b, n) => {\n\t\t\t\tlet\n\t\t\t\t\tcontext = {},\n\t\t\t\t\tcurrentSquare = b.getNeighborSquare(sq, n);\n\n\t\t\t\twhile (currentSquare) {\n\t\t\t\t\tcontext = {\n\t\t\t\t\t\tattacked : currentSquare.piece && currentSquare.piece.side !== sq.piece.side,\n\t\t\t\t\t\tblocked : currentSquare.piece && currentSquare.piece.side === sq.piece.side,\n\t\t\t\t\t\tpiece : currentSquare.piece,\n\t\t\t\t\t\tsquare : currentSquare\n\t\t\t\t\t};\n\n\t\t\t\t\tif (context.attacked) {\n\t\t\t\t\t\t// verify that the square is actually attacked\n\t\t\t\t\t\tPieceValidation\n\t\t\t\t\t\t\t.create(context.piece.type, b)\n\t\t\t\t\t\t\t.start(currentSquare, setAttacked(context));\n\t\t\t\t\t\tcurrentSquare = null;\n\t\t\t\t\t} else if (context.blocked) {\n\t\t\t\t\t\tcurrentSquare = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentSquare = b.getNeighborSquare(currentSquare, n);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn context;\n\t\t\t},\n\t\t\tisAttackedByKnight = (b, n) => {\n\t\t\t\tlet\n\t\t\t\t\tcontext,\n\t\t\t\t\tcurrentSquare = b.getNeighborSquare(sq, n);\n\n\t\t\t\tcontext = {\n\t\t\t\t\tattacked : false,\n\t\t\t\t\tblocked : false,\n\t\t\t\t\tpiece : currentSquare ? currentSquare.piece : currentSquare,\n\t\t\t\t\tsquare : currentSquare\n\t\t\t\t};\n\n\t\t\t\tif (currentSquare &&\n\t\t\t\t\tcurrentSquare.piece &&\n\t\t\t\t\tcurrentSquare.piece.type === PieceType.Knight) {\n\t\t\t\t\tPieceValidation\n\t\t\t\t\t\t.create(PieceType.Knight, b)\n\t\t\t\t\t\t.start(currentSquare, setAttacked(context));\n\t\t\t\t}\n\n\t\t\t\treturn context;\n\t\t\t},\n\t\t\tself = this,\n\t\t\tsetAttacked = (c) => {\n\t\t\t\treturn (err, squares) => {\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\tfor (i = 0; i < squares.length; i++) {\n\t\t\t\t\t\t\tif (squares[i] === sq) {\n\t\t\t\t\t\t\t\tc.attacked = true;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tc.attacked = false;\n\t\t\t\t};\n\t\t\t};\n\n\t\treturn [\n\t\t\tisAttacked(self.board, NeighborType.Above),\n\t\t\tisAttacked(self.board, NeighborType.AboveRight),\n\t\t\tisAttacked(self.board, NeighborType.Right),\n\t\t\tisAttacked(self.board, NeighborType.BelowRight),\n\t\t\tisAttacked(self.board, NeighborType.Below),\n\t\t\tisAttacked(self.board, NeighborType.BelowLeft),\n\t\t\tisAttacked(self.board, NeighborType.Left),\n\t\t\tisAttacked(self.board, NeighborType.AboveLeft),\n\t\t\t// fix for issue #4\n\t\t\tisAttackedByKnight(self.board, NeighborType.KnightAboveRight),\n\t\t\tisAttackedByKnight(self.board, NeighborType.KnightRightAbove),\n\t\t\tisAttackedByKnight(self.board, NeighborType.KnightBelowRight),\n\t\t\tisAttackedByKnight(self.board, NeighborType.KnightRightBelow),\n\t\t\tisAttackedByKnight(self.board, NeighborType.KnightBelowLeft),\n\t\t\tisAttackedByKnight(self.board, NeighborType.KnightLeftBelow),\n\t\t\tisAttackedByKnight(self.board, NeighborType.KnightAboveLeft),\n\t\t\tisAttackedByKnight(self.board, NeighborType.KnightLeftAbove)\n\t\t].filter((result) => result.attacked);\n\t}\n\n\tisSquareAttacked (sq) {\n\t\treturn this.findAttackers(sq).length !== 0;\n\t}\n\n\tstart (callback) {\n\t\t// ensure callback is set\n\t\tcallback = callback || ((err, validMoves) => new Promise((resolve, reject) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject(err);\n\t\t\t}\n\n\t\t\treturn resolve(validMoves);\n\t\t}));\n\n\t\tlet\n\t\t\ti = 0,\n\t\t\tkingSquare = null,\n\t\t\tsetValidMoves = (v, sq) => {\n\t\t\t\treturn (err, squares) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (squares && squares.length > 0) {\n\t\t\t\t\t\tv.push({\n\t\t\t\t\t\t\tsquares,\n\t\t\t\t\t\t\tsrc : sq\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\t\tsquares = [],\n\t\t\tvalidMoves = [];\n\n\t\tif (this.board) {\n\t\t\t// get squares with pieces for which to evaluate move options\n\t\t\tsquares = this.board.getSquares(this.game.getCurrentSide());\n\n\t\t\tfor (i = 0; i < squares.length; i++) {\n\t\t\t\t// set king to refer to later\n\t\t\t\tif (squares[i].piece.type === PieceType.King) {\n\t\t\t\t\tkingSquare = squares[i];\n\t\t\t\t}\n\n\t\t\t\tif (squares[i] && squares[i].piece) {\n\t\t\t\t\tPieceValidation\n\t\t\t\t\t\t.create(squares[i].piece.type, this.board)\n\t\t\t\t\t\t.start(squares[i], setValidMoves(validMoves, squares[i]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// perform king castle validation\n\t\t\tthis.evaluateCastle(validMoves);\n\n\t\t\t// make sure moves only contain escape & non-check options\n\t\t\tvalidMoves = this.filterKingAttack(kingSquare, validMoves);\n\n\t\t\t// find any pieces attacking the king\n\t\t\tthis.findAttackers(kingSquare).forEach((attacker) => {\n\t\t\t\tif (!validMoves.length) {\n\t\t\t\t\tthis.game.emit(\n\t\t\t\t\t\t'checkmate', {\n\t\t\t\t\t\t\tattackingSquare : attacker.square,\n\t\t\t\t\t\t\tkingSquare\n\t\t\t\t\t\t});\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.game.emit(\n\t\t\t\t\t'check', {\n\t\t\t\t\t\tattackingSquare : attacker.square,\n\t\t\t\t\t\tkingSquare\n\t\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\treturn callback(new Error('board is invalid'));\n\t\t}\n\n\t\treturn callback(null, validMoves);\n\t}\n}\n\nexport default { BoardValidation };"]},"metadata":{},"sourceType":"script"}